
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>Linux usb子系统（一）：子系统架构 | Born</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Born">
    

    
    <meta name="description" content="Linux usb子系统（一）：子系统架构一、USB协议基础知识   前序：USB概念概述 　　USB1.0版本速度1.5Mbps（低速USB） USB1.1版本速度12Mbps（全速USB）  USB2.0版本速度480Mbps（高速USB）。 　　USB 分为主从两大体系，一般而言， PC 中的 USB 系统就是作主，而一般的 USB 鼠标， U 盘则是典型的 USB 从系统。 　　USB主控">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux usb子系统（一）：子系统架构">
<meta property="og:url" content="http://yoursite.com/2019/04/09/Linux-usb子系统（一）：子系统架构/index.html">
<meta property="og:site_name" content="Born">
<meta property="og:description" content="Linux usb子系统（一）：子系统架构一、USB协议基础知识   前序：USB概念概述 　　USB1.0版本速度1.5Mbps（低速USB） USB1.1版本速度12Mbps（全速USB）  USB2.0版本速度480Mbps（高速USB）。 　　USB 分为主从两大体系，一般而言， PC 中的 USB 系统就是作主，而一般的 USB 鼠标， U 盘则是典型的 USB 从系统。 　　USB主控">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-09T12:02:54.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux usb子系统（一）：子系统架构">
<meta name="twitter:description" content="Linux usb子系统（一）：子系统架构一、USB协议基础知识   前序：USB概念概述 　　USB1.0版本速度1.5Mbps（低速USB） USB1.1版本速度12Mbps（全速USB）  USB2.0版本速度480Mbps（高速USB）。 　　USB 分为主从两大体系，一般而言， PC 中的 USB 系统就是作主，而一般的 USB 鼠标， U 盘则是典型的 USB 从系统。 　　USB主控">

    
    <link rel="alternative" href="/atom.xml" title="Born" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Born" title="Born"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Born">Born</a></h1>
				<h2 class="blog-motto">The life is a puzzle</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/09/Linux-usb子系统（一）：子系统架构/" title="Linux usb子系统（一）：子系统架构" itemprop="url">Linux usb子系统（一）：子系统架构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Born" target="_blank" itemprop="author">Born</a>
		
  </p><p class="article-time">
    <time datetime="2019-04-09T11:59:51.000Z" itemprop="datePublished"> 发表于 2019-04-09</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-usb子系统（一）：子系统架构"><span class="toc-number">1.</span> <span class="toc-text">Linux usb子系统（一）：子系统架构</span></a></li></ol>
		
		</div>
		
		<h3 id="Linux-usb子系统（一）：子系统架构"><a href="#Linux-usb子系统（一）：子系统架构" class="headerlink" title="Linux usb子系统（一）：子系统架构"></a>Linux usb子系统（一）：子系统架构</h3><p>一、USB协议基础知识  </p>
<p>前序：USB概念概述</p>
<p>　　USB1.0版本速度1.5Mbps（低速USB） USB1.1版本速度12Mbps（全速USB）  USB2.0版本速度480Mbps（高速USB）。</p>
<p>　　USB 分为主从两大体系，一般而言， PC 中的 USB 系统就是作主，而一般的 USB 鼠标， U 盘则是典型的 USB 从系统。</p>
<p>　　USB主控制器这一块，我们至少要开发出 USB 的主控制器与从控制器，鼠标是低速设备，所需的是最简单的一类从控制器。主控制器则复杂得多，因为太过于复杂了，所以就形成了一些标准。在一个复杂的系统中，标准的好处就是可以让开发者把精力集中在自己负责的一块中来，只需要向外界提供最标准的接口，而免于陷于技术的汪洋大海中。</p>
<p>　　USB 主控制器主要有 1.1 时代的 OHCI 和 UHCI ， 2.0 时代的 EHCI ，这些标准规定了主控制器的功能和接口（寄存器的序列及功能），对我们驱动工程师而言，这样的好处就是只要你的驱动符合标某一标准，你就能轻而易举的驱动所有这个标准的主控制器。要想把主控制器驱动起来，本来是一件很难的事情，估计全球的 IT 工程师没几个能有这样的水平，但有了标准，我们就可以轻松的占有这几个高水平的 IT 工程师的劳动成果。</p>
<p>　　主控制器和驱动有了，我们还需要 USB 协议栈，这就是整个 USB 系统的软件部分的核心（有的资料中直接把其称为 USB 核心）， USB 协议栈一方面向使用 USB 总线的设备驱动提供操作 USB 总线的 API ，另一方面则管理上层驱动传下来的的数据流，按 USB 主控制器的要求放在控制器驱动规定的位置， USB 主控制器会调度这些数据。</p>
<p>　　我们这里用到了调度这个词， USB 主控制器的调度其实和火车的调度 CPU 的调度有相似之处，物理上的通路只有一条，但 USB 中规定的逻辑上的通路却有许多条，有时一个设备就会占用几条逻辑通道，而 USB 系统中又会有多个设备同时运行。这就好像是只有一条铁路线，但来来往往的火车却有许多， USB 主控制器的作用就是调度这些火车，而 USB 协议栈的作用则向上层的 USB 设备驱动提供不同的车次。</p>
<p>　　有了以上的这些模块，才能为 USB 鼠标设计驱动，这一点上 ps/2 鼠标的驱动和 USB 鼠标的驱动结构基本一样，只不过我们的数据通路是 USB 总线。</p>
<p>　　USB 系统甚至把设备驱动都给标准化了，只要是支持 USB 的主机，就可以支持任何一个厂商的 USB 鼠标，任何一个厂商的 U 盘，只要是被 USB 系统包函的设备，只要这些设备支持相应的标准，就无需重新设计驱动而直接使用。</p>
<p>　　下是简单的列出了 USB 设备类型，理想的情况 USB 系统要对这些设备作完整的支持，设备也必须符合 USB 规范中的要求。</p>
<p>1 － audio ：表示一个音频设   备。</p>
<p>2 － communication   device ：通讯设备，如电话， moden 等等。</p>
<p>3 － HID ：人机交互设备，如键盘，鼠标等。</p>
<p>6 － image 图象设备，如扫描仪，摄像头等，有时数码相    机也可归到这一类。</p>
<p>7 －打印机类。如单向，双向打印机等。</p>
<p>8 － mass   storage 海量存储类。所有带有一定存储功能的都可以归到这一类。如数码相机大多数都归这一类。</p>
<p>9 － hub 类。</p>
<p>11 － chip   card/smart   card 。</p>
<p>13 －－ Content Security</p>
<p>14 －－ Video  （ Interface ）</p>
<p>15 －－ Personal Healthcare</p>
<p>220 －－ Diagnostic Device</p>
<p>224 －－ Wireless Controller  （ Interface ）</p>
<p>239 －－ Miscellaneous</p>
<p>254 －－ Application Specific  （ Interface ）</p>
<p>255 － vendor   specific. 厂家的自定义类，主要用于一些特殊的设备。如接口转接卡等。</p>
<p>　　随着 USB 技术的发展， USB 系统中的一些不足也逐渐被承认， OTG 就是这种情况下的主要产物。</p>
<p>　　现在市面上有些设备（比如一些 MP4 ）即能插上电脑当 U 盘使，也能被 U 盘插上读取 U 盘。这样的设备在 USB 系统中是作主还是作从呢？</p>
<p>　　这就是 OTG(On-The-Go), 即可以作主也可以作从，传说中的雌雄同体。这主要是为嵌入式设备准备的，因为 USB 是一种主从系统，不能支持点对点平等的传输数据， OTG 正是在这种需求下产生的， OTG 不仅支持控制器的主从切换，在一定层度上，也支持相同设备之间的数据交换。 </p>
<p>1、USB的传输线结构</p>
<pre><code>一条USB的传输线分别由地线、电源线、D+、D-四条线构成，D+和D-是差分输入线(抗干扰)，它使用的是3.3V的电压，而电源线和地线可向设备提供5V电压，最大电流为500MA。OTG 的做法就是增来一个 ID pin 来判断设备是接入设备的是主还是从。vbus 主要是供电， D+/D- 则是用来传输数据，就是我们前面所讲的主设备和从设备间唯一的一条铁路。
</code></pre><p>信号线名称</p>
<p>颜色</p>
<p>1</p>
<p>Vbus</p>
<p>红</p>
<p>2</p>
<p>D-</p>
<p>白</p>
<p>3</p>
<p>D+</p>
<p>绿</p>
<p>4</p>
<p>GNU</p>
<p>黑</p>
<p>shell （金属壳）</p>
<p>屏敝层</p>
<p>2、USB可以热插拔的硬件原理</p>
<p>　　USB主机是如何检测到设备的插入的呢？首先，在USB集线器的每个下游端口的D+和D-上，分别接了一个15K欧姆的下拉电阻到地。这样，在集线器的端口悬空时，就被这两个下拉电阻拉到了低电平。而在USB设备端，在D+或者D-上接了1.5K欧姆上拉电阻。对于全速和高速设备，上拉电阻是接在D+上；而低速设备则是上拉电阻接在D-上。这样，当设备插入到集线器时，由1.5K的上拉电阻和15K的下拉电阻分压，结果就将差分数据线中的一条拉高了。集线器检测到这个状态后，它就报告给USB主控制器（或者通过它上一层的集线器报告给USB主控制器），这样就检测到设备的插入了。USB高速设备先是被识别为全速设备，然后通过HOST和DEVICE两者之间的确认，再切换到高速模式的。在高速模式下，是电流传输模式，这时将D+上的上拉电阻断开。</p>
<p>3、USB主机控制器</p>
<p>　　USB主机控制器属于南桥芯片的一部分，通过PCI总线和处理器通信。USB主机控制器分为UHCI（英特尔提出）、OHCI（康柏和微软提出）、 EHCI。其中OHCI驱动程序用来为非PC系统上以及带有SiS和ALi芯片组的PC主办上的USB芯片提供支持。UHCI驱动程序多用来为大多数其他PC主板（包括Intel和Via）上的USB芯片提供支持。ENCI兼容OHCI和UHCI。UHCI的硬件线路比OHCI简单，所以成本较低，但需要较复杂的驱动程序，CPU负荷稍重。主机控制器驱动程序完成的功能主要包括：解析和维护URB，根据不同的端点进行分类缓存URB；负责不同USB传输类型的调度工作；负责USB数据的实际传输工作；实现虚拟跟HUB的功能。</p>
<p>4、USB设备的构成</p>
<p>　　USB设备的构成包括了配置，接口和端点。</p>
<p>　　1. 设备通常具有一个或者更多个配置</p>
<p>　　2. 配置经常具有一个或者更多个接口</p>
<p>　　3. 接口通常具有一个或者更多个设置</p>
<p>　　4. 接口没有或者具有一个以上的端点</p>
<p>　　需要注意的是，驱动是绑定到USB接口上，而不是整个设备。</p>
<p>5、主控制怎么正确访问各种不同的USB设备</p>
<p>　　每一个USB设备接入PC时，USB总线驱动程序都会使用默认的地址0(仅未分配地址的设备可以使用)跟USB设备通信，然后给它分配一个编号，接在USB总线上的每一个USB设备都有自己的编号(地址)，PC机想访问某个USB设备时，发出的命令都含有对应的编号(地址)就可以了。</p>
<p>　　USB总线驱动程序获取USB设置信息。USB设备里都会有一个叫 EEPROM的东东，它就是用来存储设备本身信息的。它与Flash虽说都是要电擦除的，但它可以按字节擦除，Flash只能一次擦除一个 block。</p>
<p>6、usb-firmware简易框架</p>
<p>　　usb firmware主要工作是满足usb 协议所定义的标准请求（usb协议第9章第4节），不同的firmware因为硬件不同而操作有所不同，但目的都是完成主控制器对设备的标准请求，大致框图如下：</p>
<p>7、USB传输事务</p>
<p>　　USB通信最基本的形式是通过一个名为端点（endpoint）的东西。它是真实存在的。</p>
<p>　　端点只能往一个方向传送数据（端点0除外，端点0使用message管道，它既可以IN又可以OUT），或者IN，或者OUT。除了端点0，低速设备只能有2个端点，高速设备也只能有15个IN端点和15个OUT端点。</p>
<p>　　主机和端点之间的数据传输是通过管道。</p>
<p>　　端点只有在device上才有，协议说端点代表在主机和设备端点之间移动数据的能力。</p>
<p>　　USB通信都是由host端发起的。</p>
<p>　　首先明确一点USB协议规定所有的数据传输都必须由主机发起。所以这个传输的一般格式：令牌包(表明传输的类型)，数据包(实际传输的数据)，握手包(数据的正确性)。首先是由主机控制器发出令牌包，然后主机/设备发送数据包，甚至可以没有，最后设备/主机发送握手包，这么一个过程就叫做一个USB传输事务。一个USB传输事务就实现了一次从主机和设备间的通讯。USB的事务有：OUT、IN、SETUP事务。</p>
<p>　　令牌包：可分为OUT包、IN包、SetUp包和帧起始包，OUT包就是说明接下来的数据包的方向时从主机到设备。 </p>
<p>　　数据包：里面包含的就是我们实际要传输的东东了  。</p>
<p>　　握手包：发送方发送了数据，接受方收没收到是不是该吱个声呀。</p>
<p>　　一个数据包里面包含有很多的域，里面包含了很多信息，一般有同步的域，数据包的核心信息的域，数据校验的域。</p>
<p>　　令牌包：SYNC + PID + ADDR + ENDP + CRC5 :（同步) + (IN/OUT/SetUp) + (设备地址）+（设备端点) + (校验）</p>
<p>　　数据包：分为DATA0包和DATA1包，当USB发送数据的时候，当一次发送的数据长度大于相应端点的容量时，就需要把数据包分为好几个包，分批发送，DATA0包和DATA1包交替发送，即如果第一个数据包是 DATA0，那第二个数据包就是DATA1。</p>
<p>　　　　　　SYNC + PID + DATA0/1 + CRC5:（同步) + (DATA0/1) + (数据) + (校验）。</p>
<p>　　　　　　但也有例外情况，在同步传输中（四类传输类型中之一），所有的数据包都是为DATA0，格式如下： SYNC + PID + 0~1023字节 + CRC16:（同步) + (DATA0) + (数据) + (校验）。</p>
<pre><code>握手包：SYNC+PID:(同步)+（HandShake）
</code></pre><p>8、USB协议的四种传输类型</p>
<p>　　因为usb支持的设备实在是太多，而且不同的设备对于传输数据各有各的要求和这就导致了我们需要不同的传输方式。USB支持4种传输方式：控制传输；批量传输；中断传输；实(等)时传输。</p>
<p>　　控制传输：首先发送 Setup 传输事务，然后IN/OUT传输事务，最后是 STATUS transaction，向主机汇报前面SETUP 和 IN/OUT阶段的结果。控制传输主要用于向设备发送配置信息、获取设备信息、发送命令道设备，或者获取设备的状态报告。控制传输一般发送的数据量较小，当USB设备插入时，USB核心使用端点0对设备进行配置，另外，端口0与其他端点不一样，端点0可以双向传输。</p>
<p>　　批量传输：由OUT事务和IN事务构成，用于大容量数据传输，没有固定的传输速率，也不占用带宽，当总线忙时，USB会优先进行其他类型的数据传输，而暂时停止批量转输。批量传输通常用在数据量大、对数据实时性要求不高的场合，例如USB打印机、扫描仪、大容量存储设备、U盘等。</p>
<p>　　中断传输：由OUT事务和IN事务构成，中断传输就是中断端点以一个固定的速度来传输较少的数据，USB键盘和鼠标就是使用这个传输方式。这里说的中断和硬件上下文中的中断不一样，它不是设备主动发送一个中断请求，而是主机控制器在保证不大于某个时间间隔内安排一次传输。中断传输对时间要求比较严格，所以可以用中断传输来不断地检测某个设备，当条件满足后再使用批量传输传输大量的数据。</p>
<p>　　等时传输：由OUT事务和IN事务构成，有两个特殊地方，第一，在同步传输的IN和OUT事务中是没有握手阶段；第二，在数据包阶段所有的数据包都为DATA0 。等时传输同样可以传输大批量数据，但是对数据是否到达没有保证，它对实时性的要求很高，例如音频、视频等设备（USB摄像头，USB话筒）。</p>
<p>　　这4种传输方式由4个事务组成：</p>
<p>　　IN事务：IN事务为host输入服务，当host需要从设备获得数据的时候，就需要IN事务。</p>
<p>　　OUT事务：OUT事务为host输出服务，当host需要输出数据到设备的时候，就需要OUT事务。</p>
<p>　　SETUP事务：SETUP事务为host控制服务，当host希望传输一些USB规范的默认操作的时候就需要使用setup事务。</p>
<p>　　SOF事务：这个用于帧同步。</p>
<p>　　然后这4种事务又由3类包(token包，handshake包，data包)组成，每类又分几种：</p>
<p>　　in包：in包用于指明当前的事务为in类型的。</p>
<p>　　out包: out包用于指明当前事务为out类型的。</p>
<p>　　setup包: setup包指明当前事务为setup类型的。</p>
<p>　　sof包: sof包指明当前事务为setup类型的。</p>
<p>　　ack包：ack握手包指明当前的事务的数据包传输是成功的。</p>
<p>　　nak包：nak握手包指明当前设备忙，不能处理数据包，请主机稍后再次发送。</p>
<p>　　stall包：stall握手包指明当前设备不能接受或者传输数据，表示一个严重的错误。</p>
<p>　　data0包：该数据包的类型为0。</p>
<p>　　data1包：该数据包的类型为1。</p>
<p>　　下图是一个USB鼠标插入Linux系统时完整的枚举过程，一共发生了11次传输，每次传输包括几个事务，每个事务又包括几个包，每个包包括几个域。</p>
<p>　　这里有一个概念需要注意，这里的中断传输与硬件中断那个中断是不一样的，这个中断传输实际是靠USB host control轮询usb device来实现的，而USB host control对于CPU则是基于中断的机制。</p>
<p>　　拿USB鼠标为例，USB host control对USB鼠标不断请求，这个请求的间隔是很短的，在USB spec Table 9-13端点描述符中的bInterval域中指定的，当鼠标发生过了事件之后，鼠标会发送数据回host，这时USB host control中断通知CPU，于是usb_mouse_irq被调用，在usb_mouse_irq里，就可以读取鼠标发回来的数据，当读完之后，驱动再次调用usb_submit_urb发出请求，就这么一直重复下去，一个usb鼠标的驱动也就完成了。</p>
<p>　　下面是USB鼠标中断传输图，可以看到USB host control向usb device发送了IN包，没有数据的时候device回复的是NAK,有数据的时候才向host control发送DATA包。</p>
<p>9、USB设备被识别的过程</p>
<p>　　当USB设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置。</p>
<p>　　1、接入态（Attached）：设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；</p>
<p>　　2、供电态（Powered）：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）</p>
<p>　　3、缺省态（Default）：USB在被配置之前，通过缺省地址0与主机进行通信；</p>
<p>　　4、地址态（Address）：经过了配置，USB设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；</p>
<p>　　5、配置态（Configured）：通过各种标准的USB请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。</p>
<p>　　6、挂起态（Suspended）：总线供电设备在3ms内没有总线动作，即USB总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过280UA。</p>
<p>10、标准的USB设备请求命令</p>
<p>　　USB设备请求命令是在控制传输的第一个阶段：setup事务传输的数据传输阶段发送给设备的。</p>
<p>　　标准USB设备请求命令共有11个，大小都是8个字节，具有相同的结构，由5 个字段构成。通过标准USB准设备请求，我们可以获取存储在设备EEPROM里面的信息；知道设备有哪些的设置或功能；获得设备的运行状态；改变设备的配置等。</p>
<p>　　标准USB准设备请求 = bmRequestType(1) + bRequest(2) + wvalue(2) + wIndex(2) + wLength(2)</p>
<p>　　bmRequestType：</p>
<p>　　　　[7 bit]= 0主机到设备； 1设备到主机 </p>
<p>　　　　[6-5 bit]= 00标准请求命令； 01类请求命令； 10用户定义命令； 11保留</p>
<p>　　　　[4-0 bit]= 00000 接收者为设备； 00001 接收者为接口； 00010 接收者为端点； 00011 接收者为其他接收者； 其他 其他值保留</p>
<p>　　bRequest:</p>
<p>　　　　0） 0 GET_STATUS：用来返回特定接收者的状态</p>
<p>　　　　1） 1 CLEAR_FEATURE：用来清除或禁止接收者的某些特性</p>
<p>　　　　2） 3 SET_FEATURE：用来启用或激活命令接收者的某些特性</p>
<p>　　　　3） 5 SET_ADDRESS：用来给设备分配地址</p>
<p>　　　　4） 6 GET_DEscriptOR：用于主机获取设备的特定描述符</p>
<p>　　　　5） 7 SET_DEscriptOR：修改设备中有关的描述符，或者增加新的描述符</p>
<p>　　　　6） 8 GET_CONFIGURATION：用于主机获取设备当前设备的配置值、</p>
<p>　　　　7） 9 SET_CONFIGURATION：用于主机指示设备采用的要求的配置</p>
<p>　　　　8） 10 GET_INTERFACE：用于获取当前某个接口描述符编号</p>
<p>　　　　9） 11 SET_INTERFACE：用于主机要求设备用某个描述符来描述接口</p>
<p>　　　　10） 12 SYNCH_FRAME：用于设备设置和报告一个端点的同步</p>
<p>　　wvalue: 这个字段是 request 的参数，request 不同，wValue就不同。</p>
<p>　　wIndex：wIndex，也是request 的参数，bRequestType指明 request 针对的是设备上的某个接口或端点的时候，wIndex 就用来指明是哪个接口或端点。</p>
<p>　　wLength：控制传输中 DATA transaction 阶段的长度。</p>
<p>二、Linux USB系统架构</p>
<p>这个是USB系统的拓扑图，4个部分构成：USB主机控制器，根集线器，集线器，设备。其中Root Hub与USB主机控制器是绑定在一起的。</p>
<p>　　在机箱的尾部面板上,物理上存在一,二或四个USB端口。端口可以用来连接一个普通设备或者一个hub，hub是一个USB设备，可以用来扩展连接USB设备的端口数量。最大连接USB设备数量是减去连在总线上的hub数量(如果有50个hub,那么最多77(=127-50)个设备能够连接)，剩下的就是能够连接USB设备的数量。Hub总是高速的，如果一个hub是自供电的,那么任何设备都能够附着到上面。但是如果hub是总线供电的，那么仅仅低供电(最大100mA)设备能够附着到上面，一个总线供电的hub不应该连接到另一个总线供电的hub-你应该在总线供电和自供电间交替.</p>
<p>　　通常情况下主机控制器的物理端口由一个虚拟的root hub脸管理。这个hub是有主机控制器(host controller)的设备驱动虚拟的，用来统一管理总线拓扑，因此USB子系统的驱动能够用同样的方法管理每个端口。</p>
<p>　　USB通信都是由host端发起的。USB设备驱动程序分配并初始化一个URB发给USB Core,USB Core改一改，发给USB主机控制器驱动，USB主机控制器驱动把它解析成包，在总线上进行传送。</p>
<p>　　USB Core是由内核实现的，其实也就是把host control driver里的功能更集中的向上抽象了一层，它是用来对最上层的USB设备驱动屏蔽掉host control的不同。</p>
<p>　　USB通信最基本的形式是通过一个名为端点（endpoint）的东西。它是真实存在的。端点只能往一个方向传送数据（端点0除外，端点0使用message管道，它既可以IN又可以OUT），或者IN，或者OUT（前面已经介绍过）。除了端点0，低速设备只能有2个端点，高速设备也只能有15个IN端点和15个OUT端点。主机和端点之间的数据传输是通过管道。端点只有在device上才有，协议说端点代表在主机和设备端点之间移动数据的能力。</p>
<p> 　　Linux系统下的usb部分分为四个部门或者叫做四大家族，他们是host控制器驱动、hub驱动、usb core、设备类驱动，他们共同配合着完成了对usb设备的访问操作。</p>
<p>枚举和设备描述符</p>
<p>　　每当一个USB设备附着到总线上,它将会被USB子系统枚举.也就是分配唯一的设备号(1-127)然后读取设备描述符.描述符是一个包含关于设备的信息和属性的数据结构.USB标准定义了一个描述符层次结构，下图所示：</p>
<p> 标准描述符</p>
<p>　　设备描述符： 描述USB设备的大概信息，其中包括适用于设备的全局信息，所有设备的配置。一个USB设备只有一个设备描述符。</p>
<p>　　配置描述符： 描述了特定的设备配置信息。一个USB设备可以有一或多个配置描述符。每个配置有一个或多个接口(interface)，并且每个接口有零或多个端点(endpoint)。一个端点在一个单独的配置下，是不和其他的接口共享的，但是一个单独的接口对于同一个端点能够有几种可选的配置。端点可以没有限制的在一部分不同的配置下的接口间共享。配置仅仅能够通过标准的控制传输set_configuration来激活。不同的配置能够用来全局配置信息，例如供电消耗。</p>
<p>　　接口描述符： 描述了一个配置内的特定接口。一个配置提供一个或多个接口，每个接口带有零个或多个端点描述符描述了在配置内的唯一配置。一个可以包含可选的配置的接口使得配置好的端点和/或他们的特性能够多种多样。默认的接口设置总是设置为零。可替换的设置能够在标准控制传输的set_interface来选择一个。例如一个多功能设备带有话筒的摄像头，可以有三种可用的配置来改变分配在总线上的带宽。</p>
<p>Camera activated<br>Microphone activated<br>Camera and microphone activated<br>　　端点描述符： 包含主机用来决定每个端点带宽的信息。一个端点象征一个USB设备的逻辑数据源或接收端(logic data source or sink)。端点零是用来所有的控制传输并且该端点没有设备描述符。USB spec交替使用pipe和endpoint术语。</p>
<p>　　字符串描述符： 是可选项，提供了unicode编码的额外的可读信息。他们可以是厂商和设备名称或序列号。</p>
<p>设备类型</p>
<p>　　标准的设备和接口描述符包含有关分类的内容：class, sub-class和protocol。这些字段主机可以用来设备或接口和驱动联系。依赖于分类说明是如何指定的？对于class字段和接口描述符的合法字段是由USB Device Working Group来定义的。</p>
<p>　　在Class Specification中将设备或接口分组归类并指定特性，这样就使得主机开发软件能够基于这个类别进行管理多种多样的实现。这样的主机软件通过设备中的描述信息将操作方法绑定到指定的设备。一个类别规格作为所有的该类别的设备或接口的最小操作框架服务。(PS：也就是说，所有该类别的设备或接口，都是以类别规格定义为接口框架。)</p>
<p>人机接口设备</p>
<p>　　HID分类，主要是包含人们控制计算机系统的设备。典型的HID分类设备包含: </p>
<p>　　键盘和鼠标设备例如:标准的鼠标设备，追踪球，游戏手柄。</p>
<p>　　前端面板控制   例如:旋钮，开关，按键，滚动器。</p>
<p>　　可能在电话设备，远端控制VCR，游戏或模拟设备上存在控制器。</p>
<p>再了解一下USB驱动框架：</p>
<p>　　USB总线和USB设备使用软件进行抽象描述起来是非常复杂的，一方面是协议使然，一方面也是因为它们使用太广泛了，抽象时考虑很太多情况。幸运的是，内核开发者们抽象出来的内核USB 子系统把很多复杂性都隐藏了。</p>
<p>针对上面这幅图，为了理解什么是USB子系统，我们要做以下说明：<br>　　a) USB 驱动都是夸kernel子系统的，因为最终USB设备是要通过BLCOCK 或CHAR设备的方式呈现给我们的，所以USB Driver之上还有一层。<br>　　b) USB driver利用USB Core提供的API来简单优雅的完成驱动工作，这里USB Core抽象了复杂的USB协议。<br>　　c) 主机控制器驱动位于USB软件的最下层，提供主机控制器硬件的抽象，隐藏硬件的细节，在主机控制器之下是物理的USB及所有与之连接的USB设备。主机控制器驱动只和USB Core进行关联，USB Core将用户的请求映射到相关的主机控制器驱动，从而使用户无需去访问主机控制器。<br>　　d) USB Core和USB主机控制器驱动就构成了我们的USB子系统，USB Core负责实现一些核心的功能，例如协议之类，提供一个用于访问和控制USB硬件的接口，使设备驱动不用去考虑系统当前使用哪种主机控制器。自从有了USB子系统，写USB驱动的时候，只需要调用USB Core export的接口，就几乎能完成所有工作。<br>　　e) USB总线将USB设备和USB驱动关联起来。</p>
<p>USB子系统初始化</p>
<p>　　usb初始化函数定义在内核源码（2.6.37）drivers/usb/core/usb.c:</p>
<p>复制代码<br>/*</p>
<ul>
<li><p>Init<br>*/<br>static int __init usb_init(void)<br>{<br> int retval;<br> if (nousb) {</p>
<pre><code>pr_info(&quot;%s: USB support disabled\n&quot;, usbcore_name);
return 0;
</code></pre><p> }</p>
<p> retval = usb_debugfs_init();<br> if (retval)</p>
<pre><code>goto out;
</code></pre><p> retval = bus_register(&amp;usb_bus_type);<br> if (retval)</p>
<pre><code>goto bus_register_failed;
</code></pre><p> retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br> if (retval)</p>
<pre><code>goto bus_notifier_failed;
</code></pre><p> retval = usb_major_init();<br> if (retval)</p>
<pre><code>goto major_init_failed;
</code></pre><p> retval = usb_register(&amp;usbfs_driver);<br> if (retval)</p>
<pre><code>goto driver_register_failed;
</code></pre><p> retval = usb_devio_init();<br> if (retval)</p>
<pre><code>goto usb_devio_init_failed;
</code></pre><p> retval = usbfs_init();<br> if (retval)</p>
<pre><code>goto fs_init_failed;
</code></pre><p> retval = usb_hub_init();<br> if (retval)</p>
<pre><code>goto hub_init_failed;
</code></pre><p> retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);<br> if (!retval)</p>
<pre><code>goto out;
</code></pre><p> usb_hub_cleanup();<br>hub_init_failed:<br> usbfs_cleanup();<br>fs_init_failed:<br> usb_devio_cleanup();<br>usb_devio_init_failed:<br> usb_deregister(&amp;usbfs_driver);<br>driver_register_failed:<br> usb_major_cleanup();<br>major_init_failed:<br> bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);<br>bus_notifier_failed:<br> bus_unregister(&amp;usb_bus_type);<br>bus_register_failed:<br> usb_debugfs_cleanup();<br>out:<br> return retval;<br>}</p>
</li>
</ul>
<p>subsys_initcall(usb_init);<br>复制代码<br>usb_debugfs_init():</p>
<p>　　DebugFS，顾名思义，是一种用于内核调试的虚拟文件系统，内核开发者通过debugfs和用户空间交换数据。类似的虚拟文件系统还有procfs和sysfs等，这几种虚拟文件系统都并不实际存储在硬盘上，而是Linux内核运行起来后，执行mount -t debugfs none /media/mmcblk0p2/ 才建立起来。在/media/mmcblk0p2/目录下创建usb目录并在下面创建devices文件。</p>
<p>　　当我们执行cat devices会调用usbfs_devices_fops-&gt;read(usb_device_read)函数去搜寻usb_bus_list链表下的usb设备信息，也就是所有总线下的设备。</p>
<p>bus_register：</p>
<p>　　是将usb总线注册到系统中，总线可是linux设备模型中的领导者，不管是多大的领导，也是领导，如PCI、USB、I2C，即使他们在物理上有从属关系，但是在模型的世界里，都是总线，拥有一样的待遇，所以任何一个子系统只要管理自己的设备和驱动，就需要向内核注册一个总线，注册报到。</p>
<p>bus_register_notifier：</p>
<p>　　大多数内核子系统都是相互独立的，因此某个子系统可能对其它子系统产生的事件感兴趣。为了满足这个需求，也即是让某个子系统在发生某个事件时通知其它的子系统，Linux内核提供了通知链的机制。通知链表只能够在内核的子系统之间使用，而不能够在内核与用户空间之间进行事件的通知。</p>
<p>　　通知链表是一个函数链表，链表上的每一个节点都注册了一个函数。当某个事情发生时，链表上所有节点对应的函数就会被执行。所以对于通知链表来说有一个通知方与一个接收方。在通知这个事件时所运行的函数由被通知方决定，实际上也即是被通知方注册了某个函数，在发生某个事件时这些函数就得到执行。其实和系统调用signal的思想差不多。</p>
<p>　　bus_register-&gt;BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier)，已经初始化了usb_bus_type-&gt;p-&gt;bus_notifier通过blocking_notifier_chain_register函数注册到通知链表。</p>
<p>　　那什么时候usb总线收到通知呢？</p>
<p>　　当总线发现新的设备调用device_add-&gt;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier, BUS_NOTIFY_ADD_DEVICE, dev)</p>
<p>　　当总线卸载设备时调用device_del-&gt;blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,BUS_NOTIFY_DEL_DEVICE, dev);</p>
<p>　　则调用usb_bus_nb的回调成员函数notifier_call(usb_bus_notify)，函数定义如下：</p>
<p>复制代码<br>/*</p>
<ul>
<li><p>Notifications of device and interface registration<br><em>/<br>static int usb_bus_notify(struct notifier_block </em>nb, unsigned long action,</p>
<pre><code>void *data)
</code></pre><p>{<br> struct device *dev = data;</p>
<p> switch (action) {<br> case BUS_NOTIFY_ADD_DEVICE:</p>
<pre><code>if (dev-&gt;type == &amp;usb_device_type)//usb 设备   
    (void) usb_create_sysfs_dev_files(to_usb_device(dev)); //创建descriptors文件
else if (dev-&gt;type == &amp;usb_if_device_type) //usb接口
    (void) usb_create_sysfs_intf_files(
            to_usb_interface(dev));//创建interface文件
break;
</code></pre><p> case BUS_NOTIFY_DEL_DEVICE:</p>
<pre><code>if (dev-&gt;type == &amp;usb_device_type)//usb设备
    usb_remove_sysfs_dev_files(to_usb_device(dev));//删除descriptors文件
else if (dev-&gt;type == &amp;usb_if_device_type)//usb接口
    usb_remove_sysfs_intf_files(to_usb_interface(dev));//删除interface文件
break;
</code></pre><p> }<br> return 0;<br>}<br>复制代码<br>usb_major_init：注册字符设备，主设备号180。</p>
<p>usb_register(&amp;usbfs_driver):</p>
</li>
</ul>
<p>复制代码<br>struct usb_driver usbfs_driver = {<br>    .name =     “usbfs”,<br>    .probe =    driver_probe,<br>    .disconnect =   driver_disconnect,<br>    .suspend =  driver_suspend,<br>    .resume =   driver_resume,<br>};<br>复制代码<br>　　usb_register-&gt;usb_register_driver():</p>
<p>复制代码<br>/**</p>
<ul>
<li>usb_register_driver - register a USB interface driver</li>
<li>@new_driver: USB operations for the interface driver</li>
<li>@owner: module owner of this driver.</li>
<li>@mod_name: module name string<br>*</li>
<li>Registers a USB interface driver with the USB core.  The list of</li>
<li>unattached interfaces will be rescanned whenever a new driver is</li>
<li>added, allowing the new driver to attach to any recognized interfaces.</li>
<li>Returns a negative error code on failure and 0 on success.<br>*</li>
<li>NOTE: if you want your driver to use the USB major number, you must call</li>
<li>usb_register_dev() to enable that functionality.  This function no longer</li>
<li><p>takes care of that.<br><em>/<br>int usb_register_driver(struct usb_driver </em>new_driver, struct module *owner,</p>
<pre><code>const char *mod_name)
</code></pre><p>{<br> int retval = 0;</p>
<p> if (usb_disabled())</p>
<pre><code>return -ENODEV;
</code></pre><p> new_driver-&gt;drvwrap.for_devices = 0;<br> new_driver-&gt;drvwrap.driver.name = (char *) new_driver-&gt;name;<br> new_driver-&gt;drvwrap.driver.bus = &usb_bus_type;<br> new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;<br> new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;<br> new_driver-&gt;drvwrap.driver.owner = owner;<br> new_driver-&gt;drvwrap.driver.mod_name = mod_name;<br> spin_lock_init(&amp;new_driver-&gt;dynids.lock);<br> INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);</p>
<p> retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);<br> if (retval)</p>
<pre><code>goto out;
</code></pre><p> usbfs_update_special();</p>
<p> retval = usb_create_newid_file(new_driver);<br> if (retval)</p>
<pre><code>goto out_newid;
</code></pre><p> retval = usb_create_removeid_file(new_driver);<br> if (retval)</p>
<pre><code>goto out_removeid;
</code></pre><p> pr_info(“%s: registered new interface driver %s\n”,</p>
<pre><code>usbcore_name, new_driver-&gt;name);
</code></pre></li>
</ul>
<p>out:<br>    return retval;</p>
<p>out_removeid:<br>    usb_remove_newid_file(new_driver);<br>out_newid:<br>    driver_unregister(&amp;new_driver-&gt;drvwrap.driver);</p>
<pre><code>printk(KERN_ERR &quot;%s: error %d registering interface &quot;
        &quot;    driver %s\n&quot;,
        usbcore_name, retval, new_driver-&gt;name);
goto out;
</code></pre><p>}<br>EXPORT_SYMBOL_GPL(usb_register_driver);<br>复制代码<br>其余功能如下：</p>
<p>　　1&gt; driver_register实现。后面会详细分析。</p>
<p>　　2&gt; usbfs_update_special(): 跟usb文件系统相关，看下面的usbfs_init分析。</p>
<p>　　3&gt; usb_create_newid_file(): 创建newid属性文件，在/sys/bus/usb/drivers/usbfs/下面可以看到此文件。根据传入的ID值，增加一个新的动态usb设备到驱动(这里是usbfs)，引起驱动重新探测所有的设备。</p>
<p>　　4&gt; usb_create_removeid_file():创建removeid属性文件，在/sys/bus/usb/drivers/usbfs/下面可以看到此文件。根据传入的ID值，删除驱动（这里是usbfs）里的一个usb设备。</p>
<p>　　5&gt; 输出信息：usbcore: registered new interface driver usbfs</p>
<p>现在分析driver_register功能：</p>
<p>　　1&gt; 首先判断，些驱动所属bus的subsys_private结构有没有初始化。如果没有，报bug信息。</p>
<p>　　2&gt; 判断需要注册的driver和driver所属的bus是否都有probe, remove, shutdown函数。如有，打印kernel warning信息。</p>
<p>　　3&gt; 判断此driver已经在driver所属的bus上面注册过了。如果注册过了，打印错误信息，并返回。</p>
<p>　　4&gt; 调用bus_add_driver来注册driver。</p>
<p>　　5&gt; 调用driver_add_groups来添加组属性。</p>
<p>最后对bus_add_driver进行分析。</p>
<p>复制代码<br>/**</p>
<ul>
<li>bus_add_driver - Add a driver to the bus.</li>
<li><p>@drv: driver.<br><em>/<br>int bus_add_driver(struct device_driver </em>drv)<br>{<br> struct bus_type <em>bus;<br> struct driver_private </em>priv;<br> int error = 0;</p>
<p> bus = bus_get(drv-&gt;bus);<br> if (!bus)</p>
<pre><code>return -EINVAL;
</code></pre><p> pr_debug(“bus: ‘%s’: add driver %s\n”, bus-&gt;name, drv-&gt;name);</p>
<p> priv = kzalloc(sizeof(*priv), GFP_KERNEL);<br> if (!priv) {</p>
<pre><code>error = -ENOMEM;
goto out_put_bus;
</code></pre><p> }<br> klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);<br> priv-&gt;driver = drv;<br> drv-&gt;p = priv;<br> priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;<br> error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,</p>
<pre><code>&quot;%s&quot;, drv-&gt;name);
</code></pre><p> if (error)</p>
<pre><code>goto out_unregister;
</code></pre><p> if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) {</p>
<pre><code>error = driver_attach(drv);
if (error)
    goto out_unregister;
</code></pre><p> }<br> klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);<br> module_add_driver(drv-&gt;owner, drv);</p>
<p> error = driver_create_file(drv, &amp;driver_attr_uevent);<br> if (error) {</p>
<pre><code>printk(KERN_ERR &quot;%s: uevent attr (%s) failed\n&quot;,
    __func__, drv-&gt;name);
</code></pre><p> }<br> error = driver_add_attrs(bus, drv);<br> if (error) {</p>
<pre><code>/* How the hell do we get out of this pickle? Give up */
printk(KERN_ERR &quot;%s: driver_add_attrs(%s) failed\n&quot;,
    __func__, drv-&gt;name);
</code></pre><p> }</p>
<p> if (!drv-&gt;suppress_bind_attrs) {</p>
<pre><code>error = add_bind_files(drv);
if (error) {
    /* Ditto */
    printk(KERN_ERR &quot;%s: add_bind_files(%s) failed\n&quot;,
        __func__, drv-&gt;name);
}
</code></pre><p> }</p>
<p> kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);<br> return 0;</p>
</li>
</ul>
<p>out_unregister:<br>    kobject_put(&amp;priv-&gt;kobj);<br>    kfree(drv-&gt;p);<br>    drv-&gt;p = NULL;<br>out_put_bus:<br>    bus_put(bus);<br>    return error;<br>}<br>复制代码<br>其功能是向bus中添加一个driver。</p>
<p>　　1&gt; bus_get()：bus的计数加1;</p>
<p>　　2&gt; kzalloc，分配driver_private内存空间。</p>
<p>　　3&gt; 初始化此driver的klist_devices链表。</p>
<p>　　4&gt; kobject_init_and_add()：在/sys/bus/usb/drivers/下面创建usbfs文件夹。</p>
<p>　　5&gt; 如果总线支持drivers_autoprobe，调用driver_attach。（USB 总线支持）</p>
<p>　　6&gt; driver_create_file： 在/sys/bus/usb/drivers/usbfs下面创建uevent属性文件。</p>
<p>　　7&gt; driver_add_attrs()：将总线的属性也加到/sys/bus/usb/drivers/usbfs</p>
<p>　　8&gt; add_bind_files()：在/sys/bus/usb/drivers/usbfs创建bind和unbind属性文件。</p>
<p>　　9&gt; kobject_uevent()：发送一个KOBJ_ADD的事件。</p>
<p>在/sys/bus/usb/drivers/usbfs下面的文件：</p>
<p>bind       module     new_id     remove_id    uevent     unbind</p>
<p>usb_devio_init：注册字符设备，主设备189。</p>
<p>usbfs_init:</p>
<p>复制代码<br>int __init usbfs_init(void)<br>{<br>    int retval;</p>
<pre><code>retval = register_filesystem(&amp;usb_fs_type);
if (retval)
    return retval;

usb_register_notify(&amp;usbfs_nb);

/* create mount point for usbfs */
usbdir = proc_mkdir(&quot;bus/usb&quot;, NULL);

return 0;
</code></pre><p>}<br>复制代码<br>函数功能：</p>
<p>　　1&gt; register_filesystem注册usbfs文件系统，当应用程序执行mount命令的时候，挂载文件系统到相应的目录。</p>
<p>　　2&gt; usb_register_notify函数注册到内核通知链表，当收到其他子系统通知，调用notifier_call回调函数usbfs_notify：</p>
<p>复制代码<br>static int usbfs_notify(struct notifier_block <em>self, unsigned long action, void </em>dev)<br>{<br>    switch (action) {<br>    case USB_DEVICE_ADD:<br>        usbfs_add_device(dev);//在bus号创建的目录下，根据设备号创建设备文件<br>        break;<br>    case USB_DEVICE_REMOVE:<br>        usbfs_remove_device(dev);//删除bus号创建的目录下的设备文件<br>        break;<br>    case USB_BUS_ADD:<br>        usbfs_add_bus(dev);//根据bus号创建目录<br>        break;<br>    case USB_BUS_REMOVE:<br>        usbfs_remove_bus(dev);//删除bus号创建的目录<br>    }</p>
<pre><code>usbfs_update_special();//更新文件系统节点
usbfs_conn_disc_event();

return NOTIFY_OK;
</code></pre><p>}<br>复制代码<br>　　static BLOCKING_NOTIFIER_HEAD(usb_notifier_list);usb_notifier_list通知链表初始化</p>
<p>　　usb_register_notify-&gt;blocking_notifier_chain_register(&amp;usb_notifier_list, nb)：向usb_notifier_list通知链表注册</p>
<p>　　blocking_notifier_call_chain(&amp;usb_notifier_list, USB_DEVICE_ADD, udev)：通知有usb设备增加<br>　　blocking_notifier_call_chain(&amp;usb_notifier_list,USB_DEVICE_REMOVE, udev)：通知有usb设备移除<br>　　blocking_notifier_call_chain(&amp;usb_notifier_list, USB_BUS_ADD, ubus)：通知有usb总线增加<br>　　blocking_notifier_call_chain(&amp;usb_notifier_list, USB_BUS_REMOVE, ubus)：通知有usb总线移除</p>
<p>　　3&gt; proc_mkdir在/proc/bus/目录下创建usb目录。</p>
<p>usb_register_device_driver：</p>
<p>在了解usb_generic_driver驱动前，先分析usb总线的match函数：</p>
<p>复制代码<br>static int usb_device_match(struct device <em>dev, struct device_driver </em>drv)<br>{<br>    /<em> devices and interfaces are handled separately </em>/<br>    if (is_usb_device(dev)) {</p>
<pre><code>    /* interface drivers never match devices */
    if (!is_usb_device_driver(drv))
        return 0;

    /* TODO: Add real matching code */
    return 1;

} else if (is_usb_interface(dev)) {
    struct usb_interface *intf;
    struct usb_driver *usb_drv;
    const struct usb_device_id *id;

    /* device drivers never match interfaces */
    if (is_usb_device_driver(drv))
        return 0;

    intf = to_usb_interface(dev);
    usb_drv = to_usb_driver(drv);

    id = usb_match_id(intf, usb_drv-&gt;id_table);
    if (id)
        return 1;

    id = usb_match_dynamic_id(intf, usb_drv);
    if (id)
        return 1;
}

return 0;
</code></pre><p>}</p>
<p>　　函数中我们分成两类判断：</p>
<p>　　is_usb_device()，根据设备类型dev-&gt;type == &amp;usb_device_type 来判断是否是usb设备，然后在通过for_devices（usb_register_device_driver函数注册的时候设置为1） 判断驱动是否是usb设备设备驱动，如果成功，则设备和设备驱动匹配，调用相应的驱动的probe函数（因为usb总线没有probe成员函数）。</p>
<p>　　is_usb_interface()，根据设备类型dev-&gt;type == &amp;usb_if_device_type 来判断是否是接口，然后在通过for_devices（usb_register函数注册的时候设置为0） 判断驱动是否是接口驱动，如果是接口驱动（所以调用usb_register都是注册的接口驱动，因为一个设备可以有多个接口，每个接口必须独立驱动），接着usb_match_id这个函数就是用来判断这个接口是否在id table中得到了match，一旦得到，就进入了具体接口驱动的probe函数了。。</p>
<p>　　到这里我们不禁要思索驱动找到了注册的地方，那设备来自哪里？这里也有两个函数要分析：</p>
<p>　　usb_alloc_dev()：dev-&gt;dev.type = &amp;usb_device_type，这里就表示了是usb设备，这个函数主要有两个地方调用。一个就是usb_init-&gt;usb_hub_init-&gt;hub_thread-&gt;hub_events-&gt;hub_port_connect_change，这个会在下面进行详细的分析；另外一个musb_probe-&gt;musb_init_controller-&gt;usb_add_hcd，DM8168芯片注册主控器的时候用到（或者其他芯片主控器注册）。</p>
<p>　　usb_set_configuration(): intf-&gt;dev.type = &amp;usb_if_device_type，这里就表示了是接口。</p>
<p>　　这里我们知道usb_register 和 usb_register_device_driver，一个是设备驱动的注册，一个是接口驱动的注册，match的时候通过for_devices来区分。接口指的就是一种具体的功能。</p>
<pre><code>上面我们提过每种类型的总线都有一套自己的驱动函数，看来在usb的世界里更特殊一些，usb总线下的设备驱动有一套，接口驱动也有一套：usb_probe_interface。

不管是设备还是接口都是挂在总线上的，一个总线只有一个match函数，usb_device_match。
</code></pre><p>　　在这个usb的match函数里，首先是对usb设备的match，设备的match很简单的，只要是个usb设备就认为match了，因为现在进来的usb设备统统都认为是usb_generic_driver的，都和他match。上面我们提到过这个，所有的usb设备首先都会经过筛选这一关，处理之后，才有重生的机会。接口就不一样了，如果进来的dev不是设备，就认为是个接口，然后判断drv是否为接口驱动，如果是，那么就继续判断，这个判断机制就是usb特有的了：Id。每个接口驱动注册的时候都会有一个id 的，加到了id table表中。</p>
<p>　　看了上面分析，usb match函数中涉及到的设备和接口驱动两条判断路线，在usb的世界里，真正的驱动是针对接口的，针对设备的其实是刚开始没有配置之前，一个通用的usb设备驱动，用来处理所有的usb设备，将其进入配置态，获取该配置下的各种接口，并将接口作为一种特殊的usb设备(接口设备)添加到设备模型中。</p>
<p>　　下面我们分析usb_generic_driver：</p>
<p>struct usb_device_driver usb_generic_driver = {<br>    .name =    “usb”,<br>    .probe = generic_probe,<br>    .disconnect = generic_disconnect,</p>
<p>#ifdef    CONFIG_PM<br>    .suspend = generic_suspend,<br>    .resume = generic_resume,</p>
<p>#endif<br>    .supports_autosuspend = 1,<br>};</p>
<p>　　当USB设备(只有设备先被注册之后才会分析接口，才会注册接口) 被探测并被注册到系统后(用device_add)，会调用usb_bus_type.mach()（只要是usb设备，都会跟usb_generic_driver匹配上），之后会调用usb_probe_device()，从而引发usb_generic_driver的 probe()调用，也就是generic_probe函数。</p>
<p>　　下面将会对generic_probe函数进行分析：</p>
<p>static int generic_probe(struct usb_device *udev)<br>{<br>    int err, c;</p>
<pre><code>if (udev-&gt;authorized == 0)
    dev_err(&amp;udev-&gt;dev, &quot;Device is not authorized for usage\n&quot;);
else {
    c = usb_choose_configuration(udev);
    if (c &gt;= 0) {
        err = usb_set_configuration(udev, c);
        if (err) {
            dev_err(&amp;udev-&gt;dev, &quot;can&apos;t set config #%d, error %d\n&quot;,
                c, err);
            /* This need not be fatal.  The user can try to
             * set other configurations. */
        }
    }
}
usb_notify_add_device(udev);
return 0;
</code></pre><p>}</p>
<p>　　usb_generic_driver中的generic_probe函数，这个函数是一个usb设备的第一个匹配的driver。Generic通用，只要是个usb设备就得先跟他来一段，usb设备驱动界的老大。他的probe干啥了呢？很简单！找个合适的配置，配置一下。从此usb设备就进入配置的时代了。(前期的工作谁做的呢，到这都已经设置完地址了，当然是hub了，hub发现设备后，会进行前期的枚举过程，获得配置，最终调用device_add将该usb设备添加到总线上。这个过程可以专门来一大段，是hub的主要工作，所以需要把hub单独作为一个家族来对待，人家可是走在第一线的默默无闻的工作者，默默的将设备枚举完成后，将这个设备添加到usb总线上，多伟大)。</p>
<p>　　注意：设备setconfig时参数只能为0或者合理的配置值，0就代表不配置，仍然是寻址态。不过有些设备就是拿配置0作为配置值得。</p>
<p>　　usb_choose_configuration从设备可能的众多配置(udev-&gt;descriptor.bNumConfigurations)选择一个合适的配置(struct usb_host_config)，并返回该配置的索引值。</p>
<p>//为usb device选择一个合适的配置<br>int usb_choose_configuration(struct usb_device <em>udev)<br>{<br>    int i;<br>    int num_configs;<br>    int insufficient_power = 0;<br>    struct usb_host_config </em>c, *best;</p>
<pre><code>best = NULL;
//udev-&gt;config,其实是一个数组,存放设备的配置.usb_dev-&gt;config[m]-&gt; interface[n]表示第m个配置的第n个接口的intercace结构.(m,n不是配置序号和接口序号).
c = udev-&gt;config;
//config项数
num_configs = udev-&gt;descriptor.bNumConfigurations;
//遍历所有配置项
for (i = 0; i &lt; num_configs; (i++, c++)) {
    struct usb_interface_descriptor *desc = NULL;

    //配置项的接口数目
    //取配置项的第一个接口
    if (c-&gt;desc.bNumInterfaces &gt; 0)
        desc = &amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;

    ... ...

    //电源不足.配置描述符中的电力是所需电力的1/2
    if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA) {
        insufficient_power++;
        continue;
    }

     //非标准Ethernet-over-USB协议
</code></pre><p>　　　if (i == 0 &amp;&amp; num_configs &gt; 1 &amp;&amp; desc &amp;&amp;<br>　　　　        (is_rndis(desc) || is_activesync(desc))){</p>
<p>　　　　　　… …</p>
<p>　　　　 }<br>        //选择一个不是USB_CLASS_VENDOR_SPEC的配置<br>　　　　　else if (udev-&gt;descriptor.bDeviceClass !=<br>                        USB_CLASS_VENDOR_SPEC &amp;&amp;<br>                (!desc || desc-&gt;bInterfaceClass !=<br>                        USB_CLASS_VENDOR_SPEC)) {<br>            best = c;<br>            break;<br>        }</p>
<pre><code>    /*如果所有剩下的配置是特殊的vendor,选择第一个*/
    else if (!best)
        best = c;
}

... ...

//如果选择好了配置,返回配置的序号,否则,返回-1
if (best) {
    i = best-&gt;desc.bConfigurationValue;
    dev_info(&amp;udev-&gt;dev,
        &quot;configuration #%d chosen from %d choice%s\n&quot;,
        i, num_configs, plural(num_configs));
} else {
    i = -1;
    dev_warn(&amp;udev-&gt;dev,
        &quot;no configuration chosen from %d choice%s\n&quot;,
        num_configs, plural(num_configs));
}

return i;
</code></pre><p>}    </p>
<p>　　例如：我机器上的的 usb 驱动加载时，输出：usb 1-1: configuration #1 chosen from 3 choices</p>
<p>　　表示：此设备有3个配置，而驱动最终选择了索引号为1的配置，至于选择策略是怎样的，请看usb_choose_configuration()函数。　</p>
<p>　　generic_probe函数中的usb_set_configuration函数里有很重要的动作，不是简单的设置个配置，当我们选择了某一个配置后，需要将这个配置的所有接口取出来，初始化接口作为驱动对应的一种”设备”的参数，如总线类型、设备类型等，调用device_add将该接口设备添加到设备模型中。</p>
<p>int usb_set_configuration(struct usb_device *dev, int configuration)<br>{<br>    … …</p>
<pre><code>if (cp &amp;&amp; configuration == 0)
    dev_warn(&amp;dev-&gt;dev, &quot;config 0 descriptor??\n&quot;);
</code></pre><p>　　/<em>首先,根据选择好的配置号找到相应的配置,在这里要注意了, dev-&gt;config[]数组中的配置并不是按照配置的序号来存放的,而是按照遍历到顺序来排序的.因为有些设备在发送配置描述符的时候,并不是按照配置序号来发送的,例如,配置2可能在第一次GET_CONFIGURATION就被发送了,而配置1可能是在第二次GET_CONFIGURATION才能发送.<br>　　  取得配置描述信息之后,要对它进行有效性判断,注意一下本段代码的最后几行代码:usb2.0 spec上规定,0号配置是无效配置,但是可能有些厂商的设备并末按照这一约定,所以在linux中,遇到这种情况只是打印出警告信息,然后尝试使用这一配置.</em>/<br>    n = nintf = 0;<br>    if (cp) {<br>        //接口总数<br>        nintf = cp-&gt;desc.bNumInterfaces;<br>        //在这里, 注要是为new_interfaces分配空间,要这意的是, new_interfaces是一个二级指针,它的最终指向是struct usb_interface结构.特别的,如果总电流数要小于配置所需电流,则打印出警告消息.实际上,这种情况在usb_choose_configuration()中已经进行了过滤.<br>        new_interfaces = kmalloc(nintf <em> sizeof(</em>new_interfaces),<br>                GFP_KERNEL);<br>        … … </p>
<pre><code>    for (; n &lt; nintf; ++n) {
        new_interfaces[n] = kzalloc(
                sizeof(struct usb_interface),
                GFP_KERNEL);
         ... ...
    }

    //如果总电源小于所需电流,打印警告信息
    i = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
    ... ...
}
</code></pre><p>　<br>    //要对设备进行配置了,先唤醒它<br>    ret = usb_autoresume_device(dev);<br>    if (ret)<br>        goto free_interfaces;</p>
<pre><code> //不是处于ADDRESS状态,先清除设备的状态
if (dev-&gt;state != USB_STATE_ADDRESS)
    usb_disable_device(dev, 1); /* Skip ep0 */

//确定我们有足够带宽提供这个配置
ret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);
... ...

//发送控制消息,选取配置
ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
              USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
              NULL, 0, USB_CTRL_SET_TIMEOUT);
 ... ...
}

//dev-&gt;actconfig存放的是当前设备选取的配置
dev-&gt;actconfig = cp;
 ... ...
//将状态设为CONFIGURED
usb_set_device_state(dev, USB_STATE_CONFIGURED);
/*接下来,就要对设备进行配置了,首先,将设备唤醒.只有在ADDRESS状态才能转入到CONFIG状态.(SUSPEND状态除外). 所以,如果设备当前不是处于ADDRESS状态,就需要将设备的状态初始化
接着,发送SET_CONFIGURATION的Control消息给设备,用来选择配置最后,将dev-&gt;actconfig指向选定的配置,将设备状态设为CONFIG*/

 //遍历所有的接口
for (i = 0; i &lt; nintf; ++i) {
    struct usb_interface_cache *intfc;
    struct usb_interface *intf;
    struct usb_host_interface *alt;
</code></pre><p>　     /<em>之前初始化的new_interfaces在这里终于要派上用场了.初始化各接口,从上面的初始化过程中,我们可以看出:<br>　　　　Intf-&gt;altsetting,表示接口的各种设置<br>　　　　Intf-&gt;num_altsetting:表示接口的设置数目<br>　　　　Intf-&gt;intf_assoc:接口的关联接口(定义于minor usb 2.0 spec)<br>　　　　Intf-&gt;cur_altsetting:接口的当前设置.</em>/<br>        cp-&gt;interface[i] = intf = new_interfaces[i];<br>        intfc = cp-&gt;intf_cache[i];<br>        intf-&gt;altsetting = intfc-&gt;altsetting;<br>        intf-&gt;num_altsetting = intfc-&gt;num_altsetting;<br>        //是否关联的接口描述符,定义在minor usb 2.0 spec中<br>        intf-&gt;intf_assoc = find_iad(dev, cp, i);<br>        kref_get(&amp;intfc-&gt;ref);</p>
<pre><code>//选择0号设置
alt = usb_altnum_to_altsetting(intf, 0);

//如果0号设置不存在,选排在第一个设置
if (!alt)
    alt = &amp;intf-&gt;altsetting[0];

//当前的配置
intf-&gt;cur_altsetting = alt;
</code></pre><p>　　　　 //用来启用接口,也就是启用接口中的每一个endpoint.<br>        usb_enable_interface(dev, intf);<br>        //注意这个地方对intf内嵌的struct devcie结构赋值,它的type被赋值为了usb_if_device_type.bus还是usb_bus_type.可能你已经反应过来了,要和这个device匹配的设备是interface的驱动.<br>        intf-&gt;dev.parent = &amp;dev-&gt;dev;<br>        intf-&gt;dev.driver = NULL;<br>        intf-&gt;dev.bus = &usb_bus_type;<br>        intf-&gt;dev.type = &usb_if_device_type;<br>        intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;<br>        device_initialize(&amp;intf-&gt;dev);//device 初始化<br>        mark_quiesced(intf);<br>　　　　　/<em><br>　　　　　  device的命名:<br>　　　　　　dev指的是这个接口所属的usb_dev,结合我们之前在UHCI中关于usb设备命名方式的描述.可得出它的命令方式如下:<br>　　　　　　USB总线号-设备路径:配置号.接口号.<br>　　　　　　例如,在我的虚拟机上:/sys/bus/usb/devices<br>　　　　　　1-0:1.0 usb1<br>　　　　　　可以得知,系统只有一个usb control.<br>　　　　　　1-0:1.0:表示,第一个usb control下的root hub的1号配置的0号接口.
        </em>/<br>        sprintf(&amp;intf-&gt;dev.bus_id[0], “%d-%s:%d.%d”,<br>            dev-&gt;bus-&gt;busnum, dev-&gt;devpath,<br>            configuration, alt-&gt;desc.bInterfaceNumber);<br>    }<br>    kfree(new_interfaces);</p>
<pre><code>if (cp-&gt;string == NULL)
    cp-&gt;string = usb_cache_string(dev, cp-&gt;desc.iConfiguration);

//注册每一个接口?
for (i = 0; i &lt; nintf; ++i) {
    struct usb_interface *intf = cp-&gt;interface[i];

    dev_dbg(&amp;dev-&gt;dev,
        &quot;adding %s (config #%d, interface %d)\n&quot;,
        intf-&gt;dev.bus_id, configuration,
        intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
    ret = device_add(&amp;intf-&gt;dev);//增加device
    if (ret != 0) {
        dev_err(&amp;dev-&gt;dev, &quot;device_add(%s) --&gt; %d\n&quot;,
            intf-&gt;dev.bus_id, ret);
        continue;
    }
    usb_create_sysfs_intf_files(intf);
}

//使设备suspend
usb_autosuspend_device(dev);

return 0;
</code></pre><p>}</p>
<p>　　最后,注册intf内嵌的device结构.设备配置完成了,为了省电,可以将设备置为SUSPEND状态.</p>
<p>　　到此为止usb_generic_driver凭借自己的博爱的胸襟将所有设备的各个接口添加到了linux的设备模型中。</p>
<p>　　usb设备首先以设备的身份与usb_generic_driver匹配，成功之后，会分裂出接口，当对接口调用device_add()后，会引起接口和接口驱动的匹配，这个匹配还是用usb_bus_type.mach()函数。因为接口的device-&gt;bus=&amp; usb_bus_type, 这跟usb设备是一样的，所以，都会调用到usb_bus_type.mach()，但设备和接口的处理流程是不一样的（前面已经分析过）。</p>
<p>usb_hub_init：</p>
<p>int usb_hub_init(void)<br>{<br>    if (usb_register(&amp;hub_driver) &lt; 0) {<br>        printk(KERN_ERR “%s: can’t register hub driver\n”,<br>            usbcore_name);<br>        return -1;<br>    }</p>
<pre><code>khubd_task = kthread_run(hub_thread, NULL, &quot;khubd&quot;);
if (!IS_ERR(khubd_task))
    return 0;

/* Fall through if kernel_thread failed */
usb_deregister(&amp;hub_driver);
printk(KERN_ERR &quot;%s: can&apos;t start khubd\n&quot;, usbcore_name);

return -1;
</code></pre><p>}</p>
<p>这个函数主要有两个功能：</p>
<p>　　在系统初始化的时候在usb_init函数中调用usb_hub_init函数，就进入了hub的初始化。</p>
<pre><code>对于usb_register()可以看作是usb设备中的接口驱动，而usb_register_device_driver()是一个单纯的USB设备驱动。
</code></pre><p>　　在usb_hub_init函数中完成了注册hub驱动，并且利用函数kthread_run创建一个内核线程。该线程用来管理监视hub的状态，所有的情况都通过该线程来报告。</p>
<p>　　当加载主控器的时候，在自身的platform驱动的probe函数里，调用usb_add_hcd-&gt;register_root_hub向usb总线注册root hub设备， usb总线match成功后，由usb_generic_driver驱动的probe函数，配置interface设备，然后向usb总线注册interface， usb总线再一次match， 不过这次是匹配了interface，通过ID值和hub驱动配置，因此调用hub驱动的probe函数(hub_probe)，hub_probe函数中调用hub_configure函数来配置hub，在这个函数中主要是利用函数usb_alloc_urb函数来分配一个urb，利用usb_fill_int_urb来初始化这个urb结构，包括hub的中断服务程序hub_irq的，查询的周期等。</p>
<p>　　每当有设备连接到USB接口时，USB总线在查询hub状态信息的时候会触发hub的中断服务程序hub_irq,在该函数中利用kick_khubd将hub结构通过event_list添加到khubd的队列hub_event_list，然后唤醒khubd。进入hub_events函数，该函数用来处理khubd事件队列，从khubd的hub_event_list中的每个usb_hub数据结构。该函数中首先判断hub是否出错，然后通过一个for循环来检测每个端口的状态信息。利用usb_port_status获取端口信息，如果发生变化就调用hub_port_connect_change函数来配置端口等。　</p>
<p>static void hub_events(void)<br>{<br>　　… …<br>    while (1) {</p>
<pre><code>//如果hub_event_list为空，退出
spin_lock_irq(&amp;hub_event_lock);
if (list_empty(&amp;hub_event_list)) {
    spin_unlock_irq(&amp;hub_event_lock);
    break;
}
//取hub_event_list中的后一个元素，并将其断链
tmp = hub_event_list.next;
list_del_init(tmp);
</code></pre><p>　　　　 //根据tmp获取hub<br>        hub = list_entry(tmp, struct usb_hub, event_list);<br>        //增加hub计数<br>        kref_get(&amp;hub-&gt;kref);<br>　　　　 //解锁<br>        spin_unlock_irq(&amp;hub_event_lock);</p>
<pre><code>hdev = hub-&gt;hdev;
hub_dev = hub-&gt;intfdev;
intf = to_usb_interface(hub_dev);
</code></pre><p>　　　　 … …<br>        usb_lock_device(hdev);<br>        //如果hub断开了,继续hub_event_list中的下一个<br>        if (unlikely(hub-&gt;disconnected))<br>            goto loop;</p>
<pre><code>//设备没有连接上
if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
    hub-&gt;error = -ENODEV;
    //将下面的子设备全部disable
    hub_pre_reset(intf);
    goto loop;
}

/* 自动恢复 */
ret = usb_autopm_get_interface(intf);
if (ret) {
    dev_dbg(hub_dev, &quot;Can&apos;t autoresume: %d\n&quot;, ret);
    goto loop;
}

//hub 暂停
if (hub-&gt;quiescing)
    goto loop_autopm;

//hub 有错误发生？
if (hub-&gt;error) {
    dev_dbg (hub_dev, &quot;resetting for error %d\n&quot;,
        hub-&gt;error);

    ret = usb_reset_composite_device(hdev, intf);
    if (ret) {
        dev_dbg (hub_dev,
            &quot;error resetting hub: %d\n&quot;, ret);
        goto loop_autopm;
    }

    hub-&gt;nerrors = 0;
    hub-&gt;error = 0;
}
</code></pre><p>　　　　 /<em>首先,从hub_event_list摘下第一个元素,根据我们之前在接口驱动probe过程的kick_khubd()函数分析中,有将hub-&gt; event_list添加到hub_event_list.因此,就可以顺藤摸瓜找到hub,再根据hub结构,找到接口结构和所属的usb 设备结构.<br>         然后,进行第一个重要的判断.如果hub被断开了,则,断开hub下面所连接的所有端口,这是在hub_pre_reset()中完成的.<br>         最后,进行第二个重要的判断,如果hub发生了错误,则reset它下面的所有端口,这是在usb_reset_composite_device()中完成的.</em>/</p>
<pre><code>//在这里,它遍历hub上的每一个端口,如果端口的连接会生了改变(connect_change等于1)的情况,就会调用hub_port_connect_change()
for (i = 1; i &lt;= hub-&gt;descriptor-&gt;bNbrPorts; i++) {
</code></pre><p>　　　　　　  //检测端口是否忙<br>            if (test_bit(i, hub-&gt;busy_bits))<br>                continue;<br>            //change_bits会在hub 第一次初始化时被赋值。而event_bits则在hub_irq中改变<br>            connect_change = test_bit(i, hub-&gt;change_bits);<br>            //如果都没有改变，继续测试下一个端口。<br>            if (!test_and_clear_bit(i, hub-&gt;event_bits) &amp;&amp;<br>                    !connect_change &amp;&amp; !hub-&gt;activating)<br>                continue;</p>
<pre><code>//Get_Port_Status:取得端口状态.
//会取得port的改变值和状态值
    ret = hub_port_status(hub, i,
            &amp;portstatus, &amp;portchange);
    if (ret &lt; 0)
        continue;
</code></pre><p>　　　　　　　//在struct usb_dev中,有一个struct usb_device *children[USB_MAXCHILDREN]的成员,它是表示对应端口序号上所连接的usb设备.<br>            //如果对应端口没有在设备树上,且端口显示已经连接上<br>            //将connect_change置为1<br>            if (hub-&gt;activating &amp;&amp; !hdev-&gt;children[i-1] &amp;&amp;<br>                    (portstatus &amp;<br>                        USB_PORT_STAT_CONNECTION))<br>                connect_change = 1;<br>            //端口的连接状态发生了改变.需要发送Clear_Feature<br>            if (portchange &amp; USB_PORT_STAT_C_CONNECTION) {<br>                clear_port_feature(hdev, i,<br>                    USB_PORT_FEAT_C_CONNECTION);<br>                connect_change = 1;<br>            }</p>
<pre><code>//端口的状态从enable 变为了disable
if (portchange &amp; USB_PORT_STAT_C_ENABLE) {
    if (!connect_change)
        dev_dbg (hub_dev,
            &quot;port %d enable change, &quot;
            &quot;status %08x\n&quot;,
            i, portstatus);
    clear_port_feature(hdev, i,
        USB_PORT_FEAT_C_ENABLE);

     //端口已经被停止了,且端口已经被连在设备树中.
     //需要重启一下此端口
    if (!(portstatus &amp; USB_PORT_STAT_ENABLE)
        &amp;&amp; !connect_change
        &amp;&amp; hdev-&gt;children[i-1]) {
        dev_err (hub_dev,
            &quot;port %i &quot;
            &quot;disabled by hub (EMI?), &quot;
            &quot;re-enabling...\n&quot;,
            i);
        connect_change = 1;
    }
}

//Resume完成   
if (portchange &amp; USB_PORT_STAT_C_SUSPEND) {
    clear_port_feature(hdev, i,
        USB_PORT_FEAT_C_SUSPEND);
    //如果端口连接了设备,就将设备唤醒
    if (hdev-&gt;children[i-1]) {
        ret = remote_wakeup(hdev-&gt;
                children[i-1]);
        if (ret &lt; 0)
            connect_change = 1;
    }
    //如果端口没有连接设备,就将端口禁用
    else {
        ret = -ENODEV;
        hub_port_disable(hub, i, 1);
    }
    dev_dbg (hub_dev,
        &quot;resume on port %d, status %d\n&quot;,
        i, ret);
}

//有过流保护,需要对hub power on
if (portchange &amp; USB_PORT_STAT_C_OVERCURRENT) {
    dev_err (hub_dev,
        &quot;over-current change on port %d\n&quot;,
        i);
    clear_port_feature(hdev, i,
        USB_PORT_FEAT_C_OVER_CURRENT);
    hub_power_on(hub);
}

//Reset状态已经完成了
if (portchange &amp; USB_PORT_STAT_C_RESET) {
    dev_dbg (hub_dev,
        &quot;reset change on port %d\n&quot;,
        i);
    clear_port_feature(hdev, i,
        USB_PORT_FEAT_C_RESET);
}
</code></pre><p> 　　　　　　<br>           /<em>什么情况下, hub_port_connect_change才会被设为1.<br>　　　　    1:端口在hub-&gt;change_bits中被置位.搜索整个代码树,发生在设置hub-&gt;change_bits的地方,只有在hub_port_logical_disconnect()中手动将端口禁用,会将对应位置1.<br>           2:hub上没有这个设备树上没有这个端口上的设备.但显示端口已经连上了设备<br>           3:hub这个端口上的连接发生了改变,从端口有设备连接变为无设备连接,或者从无设备连接变为有设备连接.<br>           4:hub的端口变为了disable,此时这个端口上连接了设备,但被显示该端口已经变禁用,需要将connect_change设为1.<br>           5:端口状态从SUSPEND变成了RESUME,远程唤醒端口上的设备失败,就需要将connect_change设为1.<br>           另外hub_port_connect_change()函数我们放在后面再来讨论</em>/<br>            if (connect_change)<br>                hub_port_connect_change(hub, i,<br>                        portstatus, portchange);<br>        }</p>
<pre><code> //对HUB的处理
//如果hub状态末变化，不需要做任何处理
if (test_and_clear_bit(0, hub-&gt;event_bits) == 0)
    ;   /* do nothing */
//Get_hub_status 失败?
else if (hub_hub_status(hub, &amp;hubstatus, &amp;hubchange) &lt; 0)
    dev_err (hub_dev, &quot;get_hub_status failed\n&quot;);
else {
    //这里是对应hub 状态发生了改变,且Get_hub_status正常返回的情况
    //如果hub的本地电源供电发生了改变
    if (hubchange &amp; HUB_CHANGE_LOCAL_POWER) {
        dev_dbg (hub_dev, &quot;power change\n&quot;);
        clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
        //如果是本地电源供电
        if (hubstatus &amp; HUB_STATUS_LOCAL_POWER)
            /* FIXME: Is this always true? */
            hub-&gt;limited_power = 1;
        //如果本电源不供电
        else
            hub-&gt;limited_power = 0;
    }
    //如果hub 发生过电源保护,需要对hub power on
    if (hubchange &amp; HUB_CHANGE_OVERCURRENT) {
        dev_dbg (hub_dev, &quot;overcurrent change\n&quot;);
        msleep(500);    /* Cool down */
        clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
                   hub_power_on(hub);
    }
}

hub-&gt;activating = 0;

/* If this is a root hub, tell the HCD it&apos;s okay to
 * re-enable port-change interrupts now. */
if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
    usb_enable_root_hub_irq(hdev-&gt;bus);
</code></pre><p>loop_autopm:<br>        /<em> Allow autosuspend if we’re not going to run again </em>/<br>        if (list_empty(&amp;hub-&gt;event_list))<br>            usb_autopm_enable(intf);<br>loop:<br>        usb_unlock_device(hdev);<br>        kref_put(&amp;hub-&gt;kref, hub_release);<br>    } /<em> end while (1) </em>/<br>}</p>
<p>　　hub_port_connect_change()函数分析：　</p>
<p>static void hub_port_connect_change(struct usb_hub *hub, int port1,<br>                    u16 portstatus, u16 portchange)<br>{<br>    … … </p>
<pre><code>//hub led
if (hub-&gt;has_indicators) {
    set_port_led(hub, port1, HUB_LED_AUTO);
    hub-&gt;indicator[port1-1] = INDICATOR_AUTO;
}

//忽略掉CONFIG_USB_OTG的处理
</code></pre><p>#ifdef    CONFIG_USB_OTG<br>    /<em> during HNP, don’t repeat the debounce </em>/<br>    if (hdev-&gt;bus-&gt;is_b_host)<br>        portchange &amp;= ~(USB_PORT_STAT_C_CONNECTION |<br>                USB_PORT_STAT_C_ENABLE);</p>
<p>#endif</p>
<pre><code>//尝试唤醒一个存在的设备
udev = hdev-&gt;children[port1-1];
if ((portstatus &amp; USB_PORT_STAT_CONNECTION) &amp;&amp; udev &amp;&amp;
        udev-&gt;state != USB_STATE_NOTATTACHED) {
    usb_lock_device(udev);
    if (portstatus &amp; USB_PORT_STAT_ENABLE) {
        status = 0;        /* Nothing to do */
</code></pre><p>#ifdef CONFIG_USB_SUSPEND<br>        } else if (udev-&gt;state == USB_STATE_SUSPENDED &amp;&amp;<br>                udev-&gt;persist_enabled) {<br>            /* For a suspended device, treat this as a</p>
<pre><code> * remote wakeup event.
 */
status = usb_remote_wakeup(udev);
</code></pre><p>#endif</p>
<pre><code>    } else {
        status = -ENODEV;    /* Don&apos;t resuscitate */
    }
    usb_unlock_device(udev);

    if (status == 0) {
        clear_bit(port1, hub-&gt;change_bits);
        return;
    }
}

//如果对应端口已经有设备连接,先将其断开
if (udev)
    usb_disconnect(&amp;hdev-&gt;children[port1-1]);

//接下来,将hub-&gt;change_bits的对应位清掉,该位是在函数hub_port_logical_disconnect()中被置的,在这里将其清除,免得下次在进入hub_events()的时候,再次检测到这个位发生改变.    
clear_bit(port1, hub-&gt;change_bits);

//如果发生物理断开或者连接状态改变，我们可能忘记移除设备
if (!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
        (portchange &amp; USB_PORT_STAT_C_CONNECTION))
    clear_bit(port1, hub-&gt;removed_bits);

//连接发生改变
//连接反弹的处理,实际上就是除抖动
if (portchange &amp; (USB_PORT_STAT_C_CONNECTION |
            USB_PORT_STAT_C_ENABLE)) {
    //如果该端口的连接发生改变(从有连接到无接接,或者从无连接到有连接),就有一个除抖动的过程,usb2.0 spec上规定,除抖动的时间为100ms.
    //在函数里,定义的测试时间是1500ms.如果在这个时间内,端口还末处于稳定状态,就会返回-ETIMEDOUT
    //如果已经处于稳定状态了,就会返回稳定状态下的portstatus
    status = hub_port_debounce(hub, port1);
    if (status &lt; 0) {
        if (printk_ratelimit())
            dev_err(hub_dev, &quot;connect-debounce failed, &quot;
                    &quot;port %d disabled\n&quot;, port1);
        portstatus &amp;= ~USB_PORT_STAT_CONNECTION;
    } else {
        portstatus = status;
    }
}
//如果接口上没有连接了,可以直接退出了
if (!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
        test_bit(port1, hub-&gt;removed_bits)) {

    /*经过去抖后,端口稳定的处于断开连接状态.说明端口已经没有设备了.然后,再判断hub是否有电源开关((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2),portstatus 的 USB_PORT_FEAT_POWER位是否被设置,如果没有被设置,则说明该端口断电了.
      如果hub有电源开关,且端口没有上电,则需要发送POWER的Set_Feature来为之上电*/
    if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2
            &amp;&amp; !(portstatus &amp; USB_PORT_STAT_POWER))
        set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);
</code></pre><p>　　　　　//如果端口依然处理enable状态,就会跳转到标号done处,就端口disalbe.<br>        if (portstatus &amp; USB_PORT_STAT_ENABLE)<br>              goto done;<br>        return;<br>    }</p>
<pre><code>/*如果端口隐定处于连接状态,那就需要连接端口下的设备了.首先看到的是一个for循环,是用来配置设备的两种方式.我们知道,在配置设备的时候,首先要去取设备的描述符,这个过程是在ep0上完成的.而这个ep0支持的最大传输出数据又是在设备描述符的bMaxPacketSize0中所      定义的.因此就对应有两种处理方式:
  第一种是传输8个字节,取得描述符的前面一部份,从而就可以取得bMaxPacketSize0.此后再reset设备,再根据这个bMaxPacketSize0的长度去取它的设备描述符.
  第二种是一次传输64字节,取得设备描述符的bMaxPacketSize0字段*/
for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
</code></pre><p>   　　 //为探测到的usb设备（包括普通hub，u盘等）分配并初始化udev<br>       // 在为root hub分配struct usb_dev的时候,它的第一个参数,也就是它的父结点是为NULL.<br>       /<em>我们来观察一下它在sysfs中的命名方式<br>         在没有插入U盘之前:/sys/bus/usb/devices<br>         1-0:1.0  usb1<br>         插入U盘之后:<br>         1-0:1.0  1-1  1-1:1.0  usb1<br>         增加的两个目是:<br>         1-1和1-1:1.0<br>         1-1:1.0 :只有这样的目录,表示该U盘只有一个接口,当前选取的是第0号设置项.</em>/<br>        udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);<br>        if (!udev) {<br>            dev_err (hub_dev,<br>                “couldn’t allocate port %d usb_device\n”,<br>                port1);<br>            goto done;<br>        }<br>        //置为USB_STATE_POWERED状态<br>        usb_set_device_state(udev, USB_STATE_POWERED);<br>         udev-&gt;bus_mA = hub-&gt;mA_per_port;<br>        udev-&gt;level = hdev-&gt;level + 1;<br>        udev-&gt;wusb = hub_is_wusb(hub);</p>
<pre><code>/*
 * USB 3.0 devices are reset automatically before the connect
 * port status change appears, and the root hub port status
 * shows the correct speed.  We also get port change
 * notifications for USB 3.0 devices from the USB 3.0 portion of
 * an external USB 3.0 hub, but this isn&apos;t handled correctly yet
 * FIXME.
 */
if (!(hcd-&gt;driver-&gt;flags &amp; HCD_USB3))
    udev-&gt;speed = USB_SPEED_UNKNOWN;
else if ((hdev-&gt;parent == NULL) &amp;&amp;
        (portstatus &amp; USB_PORT_STAT_SUPER_SPEED))
    udev-&gt;speed = USB_SPEED_SUPER;
else
    udev-&gt;speed = USB_SPEED_UNKNOWN;

/*为设备指定一个地址,是到所属的usb bus的bus-&gt;devmap中找到没有使用的那一位,先进行两次新的策略(i=0和=1时),如果不行就再进行两次旧的策略(i=2和i=3时).所有这一切只有一个目的,就是为了获得设备的描述符，
设置了udev-&gt;tt、udev-&gt;ttport和udev-&gt;ep    0.desc.wMaxPacketSize,设置udev-&gt;status= USB_STATE_ADDRESS。*/
choose_address(udev);
if (udev-&gt;devnum &lt;= 0) {
    status = -ENOTCONN;    /* Don&apos;t retry */
    goto loop;
}

//hub_port_init()对这个usb_dev结构进行一系的初始化,在这个函数中会处理:Get_Description,Set_address.等操作
status = hub_port_init(hub, udev, port1, i);
if (status &lt; 0)
    goto loop;

usb_detect_quirks(udev);
if (udev-&gt;quirks &amp; USB_QUIRK_DELAY_INIT)
    msleep(1000);

/* consecutive bus-powered hubs aren&apos;t reliable; they can
 * violate the voltage drop budget.  if the new child has
 * a &quot;powered&quot; LED, users should notice we didn&apos;t enable it
 * (without reading syslog), even without per-port LEDs
 * on the parent.
 */
if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB
        &amp;&amp; udev-&gt;bus_mA &lt;= 100) {
    u16    devstat;

    status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
            &amp;devstat);
    if (status &lt; 2) {
        dev_dbg(&amp;udev-&gt;dev, &quot;get status %d ?\n&quot;, status);
        goto loop_disable;
    }
    le16_to_cpus(&amp;devstat);
    if ((devstat &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
        dev_err(&amp;udev-&gt;dev,
            &quot;can&apos;t connect bus-powered hub &quot;
            &quot;to this port\n&quot;);
        if (hub-&gt;has_indicators) {
            hub-&gt;indicator[port1-1] =
                INDICATOR_AMBER_BLINK;
            schedule_delayed_work (&amp;hub-&gt;leds, 0);
        }
        status = -ENOTCONN;    /* Don&apos;t retry */
        goto loop_disable;
    }
}

/* check for devices running slower than they could */
if (le16_to_cpu(udev-&gt;descriptor.bcdUSB) &gt;= 0x0200
        &amp;&amp; udev-&gt;speed == USB_SPEED_FULL
        &amp;&amp; highspeed_hubs != 0)
    check_highspeed (hub, udev, port1);

/* Store the parent&apos;s children[] pointer.  At this point
 * udev becomes globally accessible, although presumably
 * no one will look at it until hdev is unlocked.
 */
status = 0;

// 将分配的struct usb_dev结构跟他的父结构关联起来,也就是说添加到它的父结构的usb_dev-&gt; children[]数组.
spin_lock_irq(&amp;device_state_lock);
if (hdev-&gt;state == USB_STATE_NOTATTACHED)
    status = -ENOTCONN;
else
    hdev-&gt;children[port1-1] = udev;
spin_unlock_irq(&amp;device_state_lock);

if (!status) {
  /*usb_configure_device(): 得到设备的描述符(包括设备描述符、配置描述符、接口描述符等)，分析以上描述符信息,提取出配置、接口等，并赋值给udev结构里相应的字段。
</code></pre><p>　　　　     device_add() :将usb设备注册到系统里，这个动作将触发驱动的匹配，由于这是个usb设备，所以万能usb驱动usb_generic_driver会匹配上，从而generic_probe会得到执行，从上面可以看出来，这一次hub_events()调用是由于主控制器初始化调用了<br>            hub_probe，从而引发hub_events调用。那root hub初始化完成以后hub_events会如何触发呢？答案是通过中断！而这个中断的服务函数就是hub_irq，也即是说，凡是真正的有端口变化事件发生，hub_irq就会被调用,而hub_irq()最终会调用kick_khubd()，             触发hub的event_list,于是再次调用hub_events().*/<br>            status = usb_new_device(udev);<br>            if (status) {<br>                spin_lock_irq(&amp;device_state_lock);<br>                hdev-&gt;children[port1-1] = NULL;<br>                spin_unlock_irq(&amp;device_state_lock);<br>            }<br>        }</p>
<pre><code>if (status)
    goto loop_disable;

status = hub_power_remaining(hub);
if (status)
    dev_dbg(hub_dev, &quot;%dmA power budget left\n&quot;, status);

return;
</code></pre><p>loop_disable:<br>        hub_port_disable(hub, port1, 1);<br>loop:<br>        usb_ep0_reinit(udev);<br>        release_address(udev);<br>        hub_free_dev(udev);<br>        usb_put_dev(udev);<br>        if ((status == -ENOTCONN) || (status == -ENOTSUPP))<br>            break;<br>    }<br>    if (hub-&gt;hdev-&gt;parent ||<br>            !hcd-&gt;driver-&gt;port_handed_over ||<br>            !(hcd-&gt;driver-&gt;port_handed_over)(hcd, port1))<br>        dev_err(hub_dev, “unable to enumerate USB device on port %d\n”,<br>                port1);<br>// Done标号是对应上述处理失败的处理,它禁用掉该端口(因为该端口没有连接设备或者是端口上的设备配置失败),如果是root hub,且USB控制器器驱动中又定义了relinquish_port.调用它.<br>done:<br>    hub_port_disable(hub, port1, 1);<br>    if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent)<br>        hcd-&gt;driver-&gt;relinquish_port(hcd, port1);<br>}</p>
<p> 参考了很多大神的分析，非常感谢！</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2019/04/09/Linux-usb子系统（一）：子系统架构/" data-title="Linux usb子系统（一）：子系统架构 | Born" data-tsina class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2019/04/09/lcm-ESD/" title="lcm ESD">
  <strong>上一篇：</strong><br>
  <span>
  lcm ESD</span>
</a>
</div>


<div class="next">
<a href="/2019/04/09/firstblog/" title="Born 2013的第一篇博客">
 <strong>下一篇：</strong><br> 
 <span>Born 2013的第一篇博客
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-usb子系统（一）：子系统架构"><span class="toc-number">1.</span> <span class="toc-text">Linux usb子系统（一）：子系统架构</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Born&#39;s Blog">Born&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self" frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Json Born in Google. <br>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Born">Born</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
