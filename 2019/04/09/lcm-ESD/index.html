
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  
    <title>lcm ESD | Born</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Born">
    

    
    <meta name="description" content="MTK 平台LCM ESD客制化及代码分析和案例参考文档：[FAQ14251]如何配置LCM ESD Check——读寄存器方式https://onlinesso.mediatek.com/FAQ/SW/FAQ14251[FAQ14273]MT6735/MT6753/MT6580 ESD问题攻略——外部TE方式https://onlinesso.mediatek.com/FAQ/SW/FAQ142">
<meta property="og:type" content="article">
<meta property="og:title" content="lcm ESD">
<meta property="og:url" content="http://yoursite.com/2019/04/09/lcm-ESD/index.html">
<meta property="og:site_name" content="Born">
<meta property="og:description" content="MTK 平台LCM ESD客制化及代码分析和案例参考文档：[FAQ14251]如何配置LCM ESD Check——读寄存器方式https://onlinesso.mediatek.com/FAQ/SW/FAQ14251[FAQ14273]MT6735/MT6753/MT6580 ESD问题攻略——外部TE方式https://onlinesso.mediatek.com/FAQ/SW/FAQ142">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-09T12:58:06.293Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lcm ESD">
<meta name="twitter:description" content="MTK 平台LCM ESD客制化及代码分析和案例参考文档：[FAQ14251]如何配置LCM ESD Check——读寄存器方式https://onlinesso.mediatek.com/FAQ/SW/FAQ14251[FAQ14273]MT6735/MT6753/MT6580 ESD问题攻略——外部TE方式https://onlinesso.mediatek.com/FAQ/SW/FAQ142">

    
    <link rel="alternative" href="/atom.xml" title="Born" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Born" title="Born"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Born">Born</a></h1>
				<h2 class="blog-motto">The life is a puzzle</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/09/lcm-ESD/" title="lcm ESD" itemprop="url">lcm ESD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Born" target="_blank" itemprop="author">Born</a>
		
  </p><p class="article-time">
    <time datetime="2019-04-09T12:33:40.000Z" itemprop="datePublished"> 发表于 2019-04-09</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MTK-平台LCM-ESD客制化及代码分析和案例"><span class="toc-number">1.</span> <span class="toc-text">MTK 平台LCM ESD客制化及代码分析和案例</span></a></li></ol>
		
		</div>
		
		<h3 id="MTK-平台LCM-ESD客制化及代码分析和案例"><a href="#MTK-平台LCM-ESD客制化及代码分析和案例" class="headerlink" title="MTK 平台LCM ESD客制化及代码分析和案例"></a>MTK 平台LCM ESD客制化及代码分析和案例</h3><p>参考文档：<br>[FAQ14251]如何配置LCM ESD Check——读寄存器方式<br><a href="https://onlinesso.mediatek.com/FAQ/SW/FAQ14251" target="_blank" rel="noopener">https://onlinesso.mediatek.com/FAQ/SW/FAQ14251</a><br>[FAQ14273]MT6735/MT6753/MT6580 ESD问题攻略——外部TE方式<br><a href="https://onlinesso.mediatek.com/FAQ/SW/FAQ14273" target="_blank" rel="noopener">https://onlinesso.mediatek.com/FAQ/SW/FAQ14273</a><br>[FAQ14880]LCM ESD Check 问题处理流程<br><a href="https://onlinesso.mediatek.com/FAQ/SW/FAQ14880" target="_blank" rel="noopener">https://onlinesso.mediatek.com/FAQ/SW/FAQ14880</a><br>[FAQ13728]MT6735通过读寄存器方式做ESD，客制化需求—-多个返回值<br><a href="https://onlinesso.mediatek.com/FAQ/SW/FAQ13728" target="_blank" rel="noopener">https://onlinesso.mediatek.com/FAQ/SW/FAQ13728</a></p>
<p>一．LCM ESD客制化方法<br>alps/kernel-3.18/drivers/misc/mediatek/lcm/xxx/xxx.c<br>alps/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/lcm/xxx/xxx.c<br>static void lcm_get_params(LCM_PARAMS <em>params)<br>{<br>……<br>        /</em> Esd Check方法1 : Read from lcm */<br>        params-&gt;dsi.esd_check_enable = 1;<br>        params-&gt;dsi.customization_esd_check_enable = 1;<br>        params-&gt;dsi.lcm_esd_check_table[0].cmd = 0x0A; //具体是哪个寄存器由FAE告知<br>        params-&gt;dsi.lcm_esd_check_table[0].count = 1;<br>        params-&gt;dsi.lcm_esd_check_table[0].para_list[0] = 0x1C; //读取寄存器的正确值也由FAE告知，寄存器的值要配置正确，否则会不断地esd recovery</p>
<p>/<em> Esd Check方法2 : EXT TE </em>/<br>        //params-&gt;dsi.esd_check_enable = 1;<br>        //params-&gt;dsi.customization_esd_check_enable = 0;<br>}</p>
<p>二．MT6580 LCM ESD check流程分析<br>alps/kernel-3.18/drivers/misc/mediatek/video/mt6580/videox/primary_display.c</p>
<p>int primary_display_init(char *lcm_name, unsigned int lcm_fps)<br>{<br>……<br>        primary_display_esd_check_task =<br>            kthread_create(primary_display_esd_check_worker_kthread,<br>                   NULL, “display_esd_check”);<br>……<br>//这里根据LCM中配置的params-&gt;dsi.esd_check_enable是否等于1来判断是否开启primary_display_esd_check_worker_kthread线程<br>        if (_need_do_esd_check())<br>            wake_up_process(primary_display_esd_check_task);<br>……<br>}</p>
<p>unsigned int _need_do_esd_check(void)<br>{<br>    int ret = 0;</p>
<p>#ifdef CONFIG_OF<br>    if ((pgc-&gt;plcm-&gt;params-&gt;dsi.esd_check_enable == 1)<br>        &amp;&amp; (islcmconnected == 1))<br>        ret = 1;</p>
<p>#else<br>    if (pgc-&gt;plcm-&gt;params-&gt;dsi.esd_check_enable == 1)<br>        ret = 1;</p>
<p>#endif<br>    return ret;<br>}</p>
<p>static int primary_display_esd_check_worker_kthread(void <em>data)<br>{<br>……<br>//定义esd recovery重试的次数<br>int esd_try_cnt = 5;<br>……<br>//这里每2秒扫描一次<br>        msleep(2000);    /</em> esd check and pull clock lane every 2s */<br>……<br>//执行esd check判断是否要进行esd recovery，关于primary_display_esd_check函数的分析在下面会讲到<br>        ret = primary_display_esd_check();<br>        if (ret == 1) {<br>            pr_debug(“[ESD]esd check fail, will do esd recovery\n”);<br>            i = esd_try_cnt;<br>            while (i–) {<br>                DISPCHECK(“[ESD]esd recovery try:%d\n”, i);<br>                //执行恢复动作，重新初始化显示屏参数，关于primary_display_esd_recovery函数的分析在下面有讲到<br>                primary_display_esd_recovery();<br>                //执行完恢复动作后，再次进行esd check，如果检测到的lcm寄存器的值正常，则不会再进行recovery的动作；否则会连续进行recovery和esd check，若在规定的5次内recovery均不成功，就会执行primary_display_esd_check_enable(0)关闭primary_display_esd_check_worker_kthread线程。<br>                ret = primary_display_esd_check();<br>                if (ret == 0) {<br>                    pr_debug<br>                        (“[ESD]esd recovery success\n”);<br>                    break;<br>                }<br>                pr_debug(“[ESD]after esd recovery, esd check still fail\n”);<br>                if (i == 0) {<br>                    DISPERR(<br>                    “[ESD]after esd recovery %d times, esd check still fail, disable esd check\n”,<br>                         esd_try_cnt);<br>                    primary_display_esd_check_enable(0);<br>                }<br>            }<br>        }<br>……<br>}</p>
<p>/<em> ESD CHECK FUNCTION </em>/<br>/<em> return 1: esd check fail </em>/<br>/<em> return 0: esd check pass </em>/<br>int primary_display_esd_check(void)<br>{<br>……<br>    /<em> Esd Check : EXT TE </em>/<br>    //使用TE的方式进行esd check的时候，需要在lcm的驱动中定义esd_check_enable为1，customization_esd_check_enable为0，lcm的初始化参数也要匹配TE的，主控这边的TE GPIO口需要配置正确<br>    if (pgc-&gt;plcm-&gt;params-&gt;dsi.customization_esd_check_enable == 0) {<br>        MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_extte,<br>                   MMProfileFlagStart, 0, 0);<br>        if (primary_display_is_video_mode()) {<br>            primary_display_switch_esd_mode(1);<br>            /<em> use cmdq to pull DSI clk lane</em>/<br>            if (primary_display_cmdq_enabled()) {<br>                _primary_path_lock(<strong>func</strong>);</p>
<pre><code>            /* 0.create esd check cmdq */
            cmdqRecCreate(CMDQ_SCENARIO_DISP_ESD_CHECK, &amp;(pgc-&gt;cmdq_handle_config_esd));
            _primary_path_unlock(__func__);

            /* 1.reset*/
            cmdqRecReset(pgc-&gt;cmdq_handle_config_esd);

            /* wait stream eof first */
            ret = cmdqRecWait(pgc-&gt;cmdq_handle_config_esd, CMDQ_EVENT_DISP_RDMA0_EOF);
            cmdqRecWait(pgc-&gt;cmdq_handle_config_esd, CMDQ_EVENT_MUTEX0_STREAM_EOF);

            _primary_path_lock(__func__);
            /* 2.stop dsi vdo mode */
            dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,
                        pgc-&gt;cmdq_handle_config_esd, CMDQ_STOP_VDO_MODE, 0);

            /* 3.pull DSI clock lane */
            DSI_sw_clk_trail_cmdq(0, pgc-&gt;cmdq_handle_config_esd);
            DSI_manual_enter_HS(pgc-&gt;cmdq_handle_config_esd);


            /* 4.start dsi vdo mode */
            dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,
                        pgc-&gt;cmdq_handle_config_esd, CMDQ_START_VDO_MODE, 0);

            /* 5. trigger path */
            cmdqRecClearEventToken(pgc-&gt;cmdq_handle_config_esd, CMDQ_EVENT_MUTEX0_STREAM_EOF);

            dpmgr_path_trigger(pgc-&gt;dpmgr_handle, pgc-&gt;cmdq_handle_config_esd, CMDQ_ENABLE);

            _primary_path_unlock(__func__);
            cmdqRecFlush(pgc-&gt;cmdq_handle_config_esd);

            cmdqRecDestroy(pgc-&gt;cmdq_handle_config_esd);
            pgc-&gt;cmdq_handle_config_esd = NULL;
        }
        if (_need_register_eint()) {
            MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_extte,
                       MMProfileFlagPulse, 1, 1);

            if (wait_event_interruptible_timeout
                (esd_ext_te_wq,
                 atomic_read(&amp;esd_ext_te_event),
                 HZ / 2) &gt; 0) {
                ret = 0;    /* esd check pass */
            } else {
                ret = 1;    /* esd check fail */
            }
            atomic_set(&amp;esd_ext_te_event, 0);
        }
        primary_display_switch_esd_mode(0);
    } else {
        MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_extte,
                   MMProfileFlagPulse, 0, 1);
        if (dpmgr_wait_event_timeout
            (pgc-&gt;dpmgr_handle, DISP_PATH_EVENT_IF_VSYNC,
             HZ / 2) &gt; 0) {
            ret = 0;    /* esd check pass */
        } else {
            ret = 1;    /* esd check fail */
        }
    }
    MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_extte,
               MMProfileFlagEnd, 0, ret);
    /* _primary_path_unlock(__func__); */
    goto done;
}
/* / Esd Check : Read from lcm */
//读LCM寄存器方式进行esd check和recovery
MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm, MMProfileFlagStart, 0,
           primary_display_cmdq_enabled());
if (primary_display_cmdq_enabled()) {
    _primary_path_lock(__func__);
    MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm,
               MMProfileFlagPulse, 0, 1);

    /* 0.create esd check cmdq */
    cmdqRecCreate(CMDQ_SCENARIO_DISP_ESD_CHECK,
              &amp;(pgc-&gt;cmdq_handle_config_esd));
    dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,
                  pgc-&gt;cmdq_handle_config_esd,
                  CMDQ_ESD_ALLC_SLOT, 0);
    MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm,
               MMProfileFlagPulse, 0, 2);
    DISPCHECK(&quot;[ESD]ESD config thread=%p\n&quot;, pgc-&gt;cmdq_handle_config_esd);
    _primary_path_unlock(__func__);

    /* 1.use cmdq to read from lcm */
    //发CMDQ_ESD_CHECK_READ的命令读取lcm的寄存器数据，_esd_check_config_handle_vdo函数在下面会讲到
    if (primary_display_is_video_mode())
        ret = _esd_check_config_handle_vdo();
    else
        ret = _esd_check_config_handle_cmd();

    MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm,
               MMProfileFlagPulse,
               primary_display_is_video_mode(), 3);
    if (ret == 1) {
        /* cmdq fail */
        if (_need_wait_esd_eof()) {
            /* Need set esd check eof synctoken to let trigger loop go. */
            cmdqCoreSetEvent(CMDQ_SYNC_TOKEN_ESD_EOF);
        }
        /* do dsi reset */
        dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,
                      pgc-&gt;cmdq_handle_config_esd,
                      CMDQ_DSI_RESET, 0);
        goto destroy_cmdq;
    }

    DISPCHECK(&quot;[ESD]ESD config thread done~\n&quot;);

    /* 2.check data(*cpu check now) */
    //发CMDQ_ESD_CHECK_CMP的命令，判断读取到的lcm寄存器数据和lcm驱动中定义的lcm_esd_check_table[i].para_list[0]是否一致
    ret = dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,
                    pgc-&gt;cmdq_handle_config_esd,
                    CMDQ_ESD_CHECK_CMP, 0);
    MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm,
               MMProfileFlagPulse, 0, 4);
    if (ret)
        ret = 1;    /* esd check fail */
</code></pre><p>destroy_cmdq:<br>        dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle,<br>                      pgc-&gt;cmdq_handle_config_esd,<br>                      CMDQ_ESD_FREE_SLOT, 0);<br>        /<em> 3.destroy esd config thread </em>/<br>        cmdqRecDestroy(pgc-&gt;cmdq_handle_config_esd);<br>        pgc-&gt;cmdq_handle_config_esd = NULL;<br>        /<em> _primary_path_unlock(<strong>func</strong>); </em>/<br>    }<br>……<br>return ret;<br>}</p>
<p>/<em> For Vdo Mode Read LCM Check </em>/<br>/<em> Config cmdq_handle_config_esd </em>/<br>int _esd_check_config_handle_vdo(void)<br>{<br>    int ret = 0;        /<em> 0:success , 1:fail </em>/</p>
<pre><code>primary_display_esd_cust_bycmdq(1);

/* 1.reset */
cmdqRecReset(pgc-&gt;cmdq_handle_config_esd);

/* Lock which is used to avoid esd and suspend affect */
ret = cmdqRecWait(pgc-&gt;cmdq_handle_config_esd, CMDQ_EVENT_DISP_RDMA0_EOF);
cmdqRecWait(pgc-&gt;cmdq_handle_config_esd, CMDQ_EVENT_MUTEX0_STREAM_EOF);

_primary_path_lock(__func__);

/* 2.stop dsi vdo mode */
dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle, pgc-&gt;cmdq_handle_config_esd,
              CMDQ_STOP_VDO_MODE, 0);

/* 3.write instruction(read from lcm) */
//发CMDQ_ESD_CHECK_READ的命令读取lcm的寄存器数据
dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle, pgc-&gt;cmdq_handle_config_esd, CMDQ_ESD_CHECK_READ, 0);

/* pull DSI clock lane */
DSI_sw_clk_trail_cmdq(0, pgc-&gt;cmdq_handle_config_esd);
DSI_manual_enter_HS(pgc-&gt;cmdq_handle_config_esd);

/* 4.start dsi vdo mode */
dpmgr_path_build_cmdq(pgc-&gt;dpmgr_handle, pgc-&gt;cmdq_handle_config_esd, CMDQ_START_VDO_MODE, 0);

/* 5. trigger path */
dpmgr_path_trigger(pgc-&gt;dpmgr_handle, pgc-&gt;cmdq_handle_config_esd,
           CMDQ_ENABLE);

_primary_path_unlock(__func__);

/* 6.flush instruction */
dprec_logger_start(DPREC_LOGGER_ESD_CMDQ, 0, 0);
ret = cmdqRecFlush(pgc-&gt;cmdq_handle_config_esd);
dprec_logger_done(DPREC_LOGGER_ESD_CMDQ, 0, 0);

DISPCHECK(&quot;[ESD]_esd_check_config_handle_vdo ret=%d\n&quot;, ret);

if (ret)
    ret = 1;

primary_display_esd_cust_bycmdq(0);
return ret;
</code></pre><p>}</p>
<p>alps/kernel-3.18/drivers/misc/mediatek/video/mt6580/dispsys/ddp_dsi.c<br>int ddp_dsi_build_cmdq(DISP_MODULE_ENUM module, void <em>cmdq_trigger_handle, CMDQ_STATE state)<br>{<br>……<br>    else if (state == CMDQ_ESD_CHECK_READ) {<br>    // 下发CMDQ_ESD_CHECK_READ命令的数据处理<br>        /</em> enable dsi interrupt: RD_RDY/CMD_DONE (need do this here?) */<br>        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG, DSI_REG[dsi_i]-&gt;DSI_INTEN,<br>                  RD_RDY, 1);<br>        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG, DSI_REG[dsi_i]-&gt;DSI_INTEN,<br>                  CMD_DONE, 1);</p>
<pre><code>for (i = 0; i &lt; 3; i++) {
    if (dsi_params-&gt;lcm_esd_check_table[i].cmd == 0)
        break;

    /* 0. send read lcm command(short packet) */
    t0.CONFG = 0x04;    /* /BTA */
    t0.Data0 = dsi_params-&gt;lcm_esd_check_table[i].cmd;
    /* / 0xB0 is used to distinguish DCS cmd or Gerneric cmd, is that Right??? */
    t0.Data_ID =
        (t0.Data0 &lt;
         0xB0) ? DSI_DCS_READ_PACKET_ID : DSI_GERNERIC_READ_LONG_PACKET_ID;
    t0.Data1 = 0;

    /* write DSI CMDQ */
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_CMDQ_REG[dsi_i]-&gt;data[0],
             0x00013700);
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_CMDQ_REG[dsi_i]-&gt;data[1],
             AS_UINT32(&amp;t0));
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_CMDQ_SIZE, 2);

    /* start DSI */
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_START, 0);
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_START, 1);

    /* 1. wait DSI RD_RDY(must clear, in case of cpu RD_RDY interrupt handler) */
    if (dsi_i == 0) {
        DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,
                  0x00000001, 0x1);
        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_STATUS_REG,
                  DSI_REG[dsi_i]-&gt;DSI_INTSTA, RD_RDY, 0x0);
    }
</code></pre><p>#if 0<br>            else {    /<em> DSI1 </em>/</p>
<pre><code>    DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,
              0x00000001, 0x1);
    DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_STATUS_REG,
              DSI_REG[dsi_i]-&gt;DSI_INTSTA, RD_RDY, 0x0);
}
</code></pre><p>#endif<br>            /<em> 2. save RX data </em>/<br>            if (hSlot) {<br>                DSI_BACKUPREG32(cmdq_trigger_handle,<br>                        hSlot, i <em> 4 + 0, &amp;DSI_REG[0]-&gt;DSI_RX_DATA0);<br>                DSI_BACKUPREG32(cmdq_trigger_handle,<br>                        hSlot, i </em> 4 + 1, &amp;DSI_REG[0]-&gt;DSI_RX_DATA1);<br>                DSI_BACKUPREG32(cmdq_trigger_handle,<br>                        hSlot, i <em> 4 + 2, &amp;DSI_REG[0]-&gt;DSI_RX_DATA2);<br>                DSI_BACKUPREG32(cmdq_trigger_handle,<br>                        hSlot, i </em> 4 + 3, &amp;DSI_REG[0]-&gt;DSI_RX_DATA3);<br>            }</p>
<pre><code>/* 3. write RX_RACK */
DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_RACK_REG, DSI_REG[dsi_i]-&gt;DSI_RACK,
          DSI_RACK, 1);

/* 4. polling not busy(no need clear) */
if (dsi_i == 0) {
    DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,
              0x80000000, 0);
}
</code></pre><p>#if 0<br>            else {    /<em> DSI1 </em>/</p>
<pre><code>    DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,
              0x80000000, 0);
}
</code></pre><p>#endif<br>            /<em> loop: 0~4 </em>/<br>        }</p>
<pre><code>    /* DSI_OUTREGBIT(cmdq_trigger_handle, DSI_INT_ENABLE_REG,DSI_REG[dsi_i]-&gt;DSI_INTEN,RD_RDY,0); */
} else if (state == CMDQ_ESD_CHECK_CMP) {
// 下发CMDQ_ESD_CHECK_READ命令的数据处理

    DISPCHECK(&quot;[DSI]enter cmp\n&quot;);
    /* cmp just once and only 1 return value */
    for (i = 0; i &lt; 3; i++) {
        if (dsi_params-&gt;lcm_esd_check_table[i].cmd == 0)
            break;

        DISPCHECK(&quot;[DSI]enter cmp i=%d\n&quot;, i);

        /* read data */
        if (hSlot) {
            /* read from slot */
            cmdqBackupReadSlot(hSlot, i * 4 + 0, ((uint32_t *)&amp;read_data0));
            cmdqBackupReadSlot(hSlot, i * 4 + 1, ((uint32_t *)&amp;read_data1));
            cmdqBackupReadSlot(hSlot, i * 4 + 2, ((uint32_t *)&amp;read_data2));
            cmdqBackupReadSlot(hSlot, i * 4 + 3, ((uint32_t *)&amp;read_data3));
        } else {
            /* read from dsi , support only one cmd read */
            if (i == 0) {
                DSI_OUTREG32(NULL, &amp;read_data0,
                        AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA0));
                DSI_OUTREG32(NULL, &amp;read_data1,
                        AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA1));
                DSI_OUTREG32(NULL, &amp;read_data2,
                        AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA2));
                DSI_OUTREG32(NULL, &amp;read_data3,
                        AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA3));
            }
        }

        MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm, MMProfileFlagPulse,
                   AS_UINT32(&amp;read_data0),
                   AS_UINT32(&amp;(dsi_params-&gt;lcm_esd_check_table[i])));

        DISPDBG(&quot;[DSI]enter cmp read_data0 byte0=0x%x byte1=0x%x byte2=0x%x byte3=0x%x\n&quot;,
            read_data0.byte0,
            read_data0.byte1,
            read_data0.byte2,
            read_data0.byte3);
        DISPDBG
            (&quot;[DSI]enter cmp check_table cmd=0x%x,count=0x%x,para_list[0]=0x%x,para_list[1]=0x%x\n&quot;,
             dsi_params-&gt;lcm_esd_check_table[i].cmd,
             dsi_params-&gt;lcm_esd_check_table[i].count,
             dsi_params-&gt;lcm_esd_check_table[i].para_list[0],
             dsi_params-&gt;lcm_esd_check_table[i].para_list[1]);
        DISPDBG(&quot;[DSI]enter cmp DSI+0x200=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x200));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x204=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x204));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x60=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x60));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x74=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x74));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x88=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x88));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x0c=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x0c));

        /* 0x02: acknowledge &amp; error report */
        /* 0x11: generic short read response(1 byte return) */
        /* 0x12: generic short read response(2 byte return) */
        /* 0x1a: generic long read response */
        /* 0x1c: dcs long read response */
        /* 0x21: dcs short read response(1 byte return) */
        /* 0x22: dcs short read response(2 byte return) */
        //根据读取到read_data0.byte0的值，来判断lcm发过来的是什么类型的数据包，进行相应的判断处理
        packet_type = read_data0.byte0;

        if (packet_type == 0x1A || packet_type == 0x1C) {
            recv_data_cnt = read_data0.byte1 + read_data0.byte2 * 16;
            if (recv_data_cnt &gt; 2) {
                DISPCHECK
                (&quot;Set receive data count from %d to 2 as ESD check supported max data count.\n&quot;,
                    recv_data_cnt);
                recv_data_cnt = 2;
            }
            if (recv_data_cnt &gt; dsi_params-&gt;lcm_esd_check_table[i].count) {
                DISPCHECK
                (&quot;Set receive data count from %d to %d as ESD check table specified.\n&quot;,
                        recv_data_cnt, dsi_params-&gt;lcm_esd_check_table[i].count);
                recv_data_cnt = dsi_params-&gt;lcm_esd_check_table[i].count;
            }
            DISPCHECK(&quot;DSI read long packet size: %d\n&quot;, recv_data_cnt);
            //比较这种lcm中配置的lcm_esd_check_table[i].para_list[0]值和read_data1.byte0的值是否一致
            result = memcmp((void *)&amp;(dsi_params-&gt;lcm_esd_check_table[i].para_list[0]),
                (void *)&amp;read_data1, recv_data_cnt);
        } else if (packet_type == 0x11 ||
               packet_type == 0x12 ||
               packet_type == 0x21 ||
               packet_type == 0x22) {
            /* short read response */
            if (packet_type == 0x11 || packet_type == 0x21)
                recv_data_cnt = 1;
            else
                recv_data_cnt = 2;

            if (recv_data_cnt &gt; dsi_params-&gt;lcm_esd_check_table[i].count) {
                DISPCHECK
                (&quot;Set receive data count from %d to %d as ESD check table specified.\n&quot;,
                    recv_data_cnt, dsi_params-&gt;lcm_esd_check_table[i].count);
                recv_data_cnt = dsi_params-&gt;lcm_esd_check_table[i].count;
            }
            DISPCHECK(&quot;DSI read short packet size: %d\n&quot;, recv_data_cnt);
            //比较这种lcm中配置的lcm_esd_check_table[i].para_list[0]值和read_data0.byte1的值是否一致
            result = memcmp((void *)&amp;(dsi_params-&gt;lcm_esd_check_table[i].para_list[0]),
                    (void *)&amp;read_data0.byte1, recv_data_cnt);
        } else if (packet_type == 0x02) {
            DISPCHECK(&quot;read return type is 0x02\n&quot;);
            result = 1;
        } else {
            DISPCHECK(&quot;read return type is non-recognite, type = 0x%x\n&quot;, packet_type);
            result = 1;
        }

        if (result == 0) {
            /* clear rx data */
            /* DSI_OUTREG32(NULL, &amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA0,0); */
            // result等于0的话，esd是ok的，不会进行recovery的动作
            ret = 0; /* esd pass */
        } else {
            // result等于1的话，esd是fail的，会进行recovery的动作
            ret = 1; /* esd fail */
            break;
        }
    }

}
</code></pre><p>……<br>}</p>
<p>alps/kernel-3.18/drivers/misc/mediatek/video/mt6580/videox/primary_display.c<br>/<em> ESD RECOVERY </em>/<br>int primary_display_esd_recovery(void)<br>{<br>……<br>//重新初始化显示屏参数<br>    disp_lcm_init(pgc-&gt;plcm, 1);<br>……<br>}</p>
<p>alps/kernel-3.18/drivers/misc/mediatek/video/mt6580/videox/disp_lcm.c<br>int disp_lcm_init(disp_lcm_handle <em>plcm, int force)<br>{<br>        LCM_DRIVER </em>lcm_drv = NULL;</p>
<pre><code>DISPFUNC();
if (_is_lcm_inited(plcm)) {
        lcm_drv = plcm-&gt;drv;

        if (lcm_drv-&gt;init_power) {
                if (!disp_lcm_is_inited(plcm) || force) {
                        DISPMSG(&quot;lcm init power()\n&quot;);
                        lcm_drv-&gt;init_power();
                }
        }

        if (lcm_drv-&gt;init) {
                if (!disp_lcm_is_inited(plcm) || force) {
                        DISPMSG(&quot;lcm init()\n&quot;);
                        //这里就是调用到lcm的static void lcm_init(void)函数
                        lcm_drv-&gt;init();
                }
        } else {
                DISPERR(&quot;FATAL ERROR, lcm_drv-&gt;init is null\n&quot;);
                return -1;
        }

        return 0;
}

DISPERR(&quot;plcm is null\n&quot;);
return -1;
</code></pre><p>}</p>
<p>三．读寄存器方式做ESD检测，目前只支持读取三个寄存器，各个寄存器只能够识别返回一个值。（只能够识别屏端返回的短包），如果需要识别返回多个值，可以做如下修改<br>（1）<br>alps/kernel-3.18/drivers/misc/mediatek/lcm/inc/lcm_drv.h</p>
<p>#define RT_MAX_NUM 10 //该值不可以修改，最大只支持10个返回值</p>
<p>#define ESD_CHECK_NUM 3 //该值表示目前最多可以读取的寄存器个数，尽量不要修改，修改成越大，esc check的负载越重，系统运行时更慢<br>typedef struct {<br>        unsigned char cmd;<br>        unsigned char count;<br>        unsigned char para_list[RT_MAX_NUM];<br>} LCM_esd_check_item;<br>typedef struct {<br>……<br>        LCM_esd_check_item lcm_esd_check_table[ESD_CHECK_NUM];<br>……<br>} LCM_DSI_PARAMS;</p>
<p>（2）<br>alps/kernel-3.18/drivers/misc/mediatek/lcm/xxx/xxx.c<br>alps/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/lcm/xxx/xxx.c<br>static void lcm_get_params(LCM_PARAMS *params)<br>{<br>……<br>        //配置三个lcm的寄存器地址，每个寄存器配置10个值，如下，寄存器的值要配置正确，否则会不断地esd recovery<br>params-&gt;dsi.esd_check_enable = 1;<br>        params-&gt;dsi.customization_esd_check_enable = 1;</p>
<pre><code>params-&gt;dsi.lcm_esd_check_table[0].cmd = 0xBa;
params-&gt;dsi.lcm_esd_check_table[0].count = 10; 
params-&gt;dsi.lcm_esd_check_table[0].para_list[0] = 0x32;
params-&gt;dsi.lcm_esd_check_table[0].para_list[1] = 0x81;
params-&gt;dsi.lcm_esd_check_table[0].para_list[2] = 0x05;
params-&gt;dsi.lcm_esd_check_table[0].para_list[3] = 0xF9;
params-&gt;dsi.lcm_esd_check_table[0].para_list[4] = 0x0e;
params-&gt;dsi.lcm_esd_check_table[0].para_list[5] = 0x0e;
params-&gt;dsi.lcm_esd_check_table[0].para_list[6] = 0x02;
params-&gt;dsi.lcm_esd_check_table[0].para_list[7] = 0x00;
params-&gt;dsi.lcm_esd_check_table[0].para_list[8] = 0x00;
params-&gt;dsi.lcm_esd_check_table[0].para_list[9] = 0x00;

params-&gt;dsi.lcm_esd_check_table[1].cmd = 0xc1;
params-&gt;dsi.lcm_esd_check_table[1].count = 10; 
params-&gt;dsi.lcm_esd_check_table[1].para_list[0] = 0x54;
params-&gt;dsi.lcm_esd_check_table[1].para_list[1] = 0x00;
params-&gt;dsi.lcm_esd_check_table[1].para_list[2] = 0x1E;
params-&gt;dsi.lcm_esd_check_table[1].para_list[3] = 0x1E;
params-&gt;dsi.lcm_esd_check_table[1].para_list[4] = 0x77;
params-&gt;dsi.lcm_esd_check_table[1].para_list[5] = 0xF1;
params-&gt;dsi.lcm_esd_check_table[1].para_list[6] = 0xFF;
params-&gt;dsi.lcm_esd_check_table[1].para_list[7] = 0xFF;
params-&gt;dsi.lcm_esd_check_table[1].para_list[8] = 0xCC;
params-&gt;dsi.lcm_esd_check_table[1].para_list[9] = 0xCC;

params-&gt;dsi.lcm_esd_check_table[2].cmd = 0xe9;
params-&gt;dsi.lcm_esd_check_table[2].count = 10; 
params-&gt;dsi.lcm_esd_check_table[2].para_list[0] = 0x02;
params-&gt;dsi.lcm_esd_check_table[2].para_list[1] = 0x00;
params-&gt;dsi.lcm_esd_check_table[2].para_list[2] = 0x10;
params-&gt;dsi.lcm_esd_check_table[2].para_list[3] = 0x05;
params-&gt;dsi.lcm_esd_check_table[2].para_list[4] = 0x16;
params-&gt;dsi.lcm_esd_check_table[2].para_list[5] = 0x0A;
params-&gt;dsi.lcm_esd_check_table[2].para_list[6] = 0xA0;
params-&gt;dsi.lcm_esd_check_table[2].para_list[7] = 0x12;
params-&gt;dsi.lcm_esd_check_table[2].para_list[8] = 0x31;
params-&gt;dsi.lcm_esd_check_table[2].para_list[9] = 0x23;
</code></pre><p>}</p>
<p>（3）<br>alps/kernel-3.18/drivers/misc/mediatek/video/mt6735/ddp_dsi.c<br>int ddp_dsi_build_cmdq(DISP_MODULE_ENUM module, void <em>cmdq_trigger_handle, CMDQ_STATE state)<br>{<br>    int ret = 0, result = 0;<br>    int i = 0, j = 0;<br>    int dsi_i = 0;<br>    LCM_DSI_PARAMS </em>dsi_params = NULL;<br>    DSI_T0_INS t0, t1;<br>    struct DSI_RX_DATA_REG read_data0,read_data1,read_data2,read_data3;<br>    unsigned char buffer[20];<br>    uint32_t recv_data_cnt;<br>    unsigned char packet_type;<br>    unsigned int h = 0;</p>
<pre><code>static cmdqBackupSlotHandle hSlot[4] = {0, 0, 0, 0};

if (DISP_MODULE_DSIDUAL == module)
    dsi_i = 0;
else
    dsi_i = DSI_MODULE_to_ID(module);

dsi_params = &amp;_dsi_context[dsi_i].dsi_params;

if (cmdq_trigger_handle == NULL) {
    DISPMSG(&quot;cmdq_trigger_handle is NULL\n&quot;);
    return -1;
}

if (state == CMDQ_BEFORE_STREAM_SOF) {
    /* need waiting te */
    if (module == DISP_MODULE_DSI0) {
        if (dsi0_te_enable == 0)
            return 0;
</code></pre><p>#ifndef MTK_FB_CMDQ_DISABLE<br>            ret =<br>                cmdqRecClearEventToken(cmdq_trigger_handle, CMDQ_EVENT_DSI_TE);<br>            ret = cmdqRecWait(cmdq_trigger_handle, CMDQ_EVENT_DSI_TE);</p>
<p>#endif<br>        }</p>
<p>#if 0<br>        else if (module == DISP_MODULE_DSI1) {<br>            if (dsi1_te_enable == 0)<br>                return 0;</p>
<pre><code>    ret =
        cmdqRecClearEventToken(cmdq_trigger_handle,
                   CMDQ_EVENT_MDP_DSI1_TE_SOF);
    ret = cmdqRecWait(cmdq_trigger_handle, CMDQ_EVENT_MDP_DSI1_TE_SOF);
} else if (module == DISP_MODULE_DSIDUAL) {
    if (dsidual_te_enable == 0)
        return 0;

    /* TODO: dsi 8 lane do not use te???? */
    /* ret = cmdqRecWait(cmdq_trigger_handle, CMDQ_EVENT_MDP_DSI0_TE_SOF); */
}
</code></pre><p>#endif<br>        else {<br>            DISPERR(“wrong module: %s\n”, ddp_get_module_name(module));<br>            return -1;<br>        }<br>    } else if (state == CMDQ_CHECK_IDLE_AFTER_STREAM_EOF) {<br>        /<em> need waiting te </em>/<br>        if (module == DISP_MODULE_DSI0) {<br>            DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,<br>                      0x80000000, 0);<br>        }</p>
<p>#if 0<br>        else if (module == DISP_MODULE_DSI1) {<br>            DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA,<br>                      0x80000000, 0);<br>        } else if (module == DISP_MODULE_DSIDUAL) {<br>            DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[0]-&gt;DSI_INTSTA,<br>                      0x80000000, 0);<br>            DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[1]-&gt;DSI_INTSTA,<br>                      0x80000000, 0);<br>        }</p>
<p>#endif<br>        else {<br>            DISPERR(“wrong module: %s\n”, ddp_get_module_name(module));<br>            return -1;<br>        }<br>    } else if (state == CMDQ_ESD_CHECK_READ) {<br>        /<em> enable dsi interrupt: RD_RDY/CMD_DONE (need do this here?) </em>/<br>        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG,<br>                  DSI_REG[dsi_i]-&gt;DSI_INTEN, RD_RDY, 1);<br>        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG,<br>                  DSI_REG[dsi_i]-&gt;DSI_INTEN, CMD_DONE, 1);</p>
<pre><code>for (i = 0; i &lt; 3; i++) {
    if (dsi_params-&gt;lcm_esd_check_table[i].cmd == 0)
        break;

    /* 0. send read lcm command(short packet) */
    t0.CONFG = 0x04;    /* BTA */
    t0.Data0 = dsi_params-&gt;lcm_esd_check_table[i].cmd;
    /* / 0xB0 is used to distinguish DCS cmd or Gerneric cmd, is that Right??? */
    t0.Data_ID =
        (t0.Data0 &lt;
         0xB0) ? DSI_DCS_READ_PACKET_ID :
        DSI_GERNERIC_READ_LONG_PACKET_ID;
    t0.Data1 = 0;

    t1.CONFG = 0x00;
    t1.Data0 = dsi_params-&gt;lcm_esd_check_table[i].count;
    t1.Data1 = 0x00;
    t1.Data_ID = 0x37;

    /* write DSI CMDQ */
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_CMDQ_REG[dsi_i]-&gt;data[0],
             AS_UINT32(&amp;t1));
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_CMDQ_REG[dsi_i]-&gt;data[1],
             AS_UINT32(&amp;t0));
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_CMDQ_SIZE,
             2);

    /* start DSI */
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_START, 0);
    DSI_OUTREG32(cmdq_trigger_handle, &amp;DSI_REG[dsi_i]-&gt;DSI_START, 1);

    /* 1. wait DSI RD_RDY(must clear, in case of cpu RD_RDY interrupt handler) */
    if (dsi_i == 0) {    /* DSI0 */
        DSI_POLLREG32(cmdq_trigger_handle,
                  &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA, 0x00000001, 0x1);
        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_STATUS_REG,
                  DSI_REG[dsi_i]-&gt;DSI_INTSTA, RD_RDY, 0);
    }
</code></pre><p>#if 0<br>            else {    /<em> DSI1 </em>/<br>                DSI_POLLREG32(cmdq_trigger_handle,<br>                          &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA, 0x00000001, 0x1);<br>                DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_STATUS_REG,<br>                          DSI_REG[dsi_i]-&gt;DSI_INTSTA, RD_RDY, 0);<br>            }</p>
<p>#endif<br>            /<em> 2. save RX data </em>/<br>            if (hSlot[0] &amp;&amp; hSlot[1] &amp;&amp; hSlot[2] &amp;&amp; hSlot[3]) {<br>                DSI_BACKUPREG32(cmdq_trigger_handle, hSlot[0], i,<br>                &amp;DSI_REG[0]-&gt;DSI_RX_DATA0);<br>                DSI_BACKUPREG32(cmdq_trigger_handle, hSlot[1], i,<br>                &amp;DSI_REG[0]-&gt;DSI_RX_DATA1);<br>                DSI_BACKUPREG32(cmdq_trigger_handle, hSlot[2], i,<br>                &amp;DSI_REG[0]-&gt;DSI_RX_DATA2);<br>                DSI_BACKUPREG32(cmdq_trigger_handle, hSlot[3], i,<br>                &amp;DSI_REG[0]-&gt;DSI_RX_DATA3);<br>            } </p>
<pre><code>/* 3. write RX_RACK */
DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_RACK_REG,
          DSI_REG[dsi_i]-&gt;DSI_RACK, DSI_RACK, 1);

/* 4. polling not busy(no need clear) */
if (dsi_i == 0) {    /* DSI0 */
    DSI_POLLREG32(cmdq_trigger_handle,
              &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA, 0x80000000, 0);
}
</code></pre><p>#if 0<br>            else {    /<em> DSI1 </em>/<br>                DSI_POLLREG32(cmdq_trigger_handle,<br>                          &amp;DSI_REG[dsi_i]-&gt;DSI_INTSTA, 0x80000000, 0);<br>            }</p>
<p>#endif<br>            /<em> loop: 0~4 </em>/<br>        }</p>
<pre><code>    /* DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG,DSI_REG[dsi_i]-&gt;DSI_INTEN,RD_RDY,0); */
} else if (state == CMDQ_ESD_CHECK_CMP) {

    DISPMSG(&quot;[DSI]enter cmp\n&quot;);
    /* cmp just once and only 1 return value */
    for (i = 0; i &lt; 3; i++) {
        if (dsi_params-&gt;lcm_esd_check_table[i].cmd == 0)
            break;

        DISPMSG(&quot;[DSI]enter cmp i=%d\n&quot;, i);

        /* read data */
        if (hSlot[0] &amp;&amp; hSlot[1] &amp;&amp; hSlot[2] &amp;&amp; hSlot[3]) {
            /* read from slot */
            cmdqBackupReadSlot(hSlot[0], i, ((uint32_t *)&amp;read_data0));
            cmdqBackupReadSlot(hSlot[1], i, ((uint32_t *)&amp;read_data1));
            cmdqBackupReadSlot(hSlot[2], i, ((uint32_t *)&amp;read_data2));
            cmdqBackupReadSlot(hSlot[3], i, ((uint32_t *)&amp;read_data3)); 
        } else {
            /* read from dsi , support only one cmd read */
            if (i == 0) {
                DSI_OUTREG32(NULL, &amp;read_data0,AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA0));
                DSI_OUTREG32(NULL, &amp;read_data1,AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA1));
                DSI_OUTREG32(NULL, &amp;read_data2,AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA2));
                DSI_OUTREG32(NULL, &amp;read_data3,AS_UINT32(&amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA3));
            }
        }

        MMProfileLogEx(ddp_mmp_get_events()-&gt;esd_rdlcm, MMProfileFlagPulse,
                   AS_UINT32(&amp;read_data0),
                   AS_UINT32(&amp;(dsi_params-&gt;lcm_esd_check_table[i])));

        DISPDBG
            (&quot;[DSI]enter cmp read_data0 byte0=0x%x byte1=0x%x byte2=0x%x byte3=0x%x\n&quot;,
             read_data0.byte0, read_data0.byte1, read_data0.byte2,
             read_data0.byte3);
        DISPDBG
            (&quot;[DSI]cmp check_table cmd=0x%x,count=0x%x,para_list[0]=0x%x,para_list[1]=0x%x\n&quot;,
             dsi_params-&gt;lcm_esd_check_table[i].cmd,
             dsi_params-&gt;lcm_esd_check_table[i].count,
             dsi_params-&gt;lcm_esd_check_table[i].para_list[0],
             dsi_params-&gt;lcm_esd_check_table[i].para_list[1]);
        DISPDBG(&quot;[DSI]enter cmp DSI+0x200=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x200));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x204=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x204));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x60=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x60));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x74=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x74));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x88=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x88));
        DISPDBG(&quot;[DSI]enter cmp DSI+0x0c=0x%x\n&quot;,
            AS_UINT32(DDP_REG_BASE_DSI0 + 0x0c));

        /* 0x02: acknowledge &amp; error report */
        /* 0x11: generic short read response(1 byte return) */
        /* 0x12: generic short read response(2 byte return) */
        /* 0x1a: generic long read response */
        /* 0x1c: dcs long read response */
        /* 0x21: dcs short read response(1 byte return) */
        /* 0x22: dcs short read response(2 byte return) */
        packet_type = read_data0.byte0;

        if (packet_type == 0x1A || packet_type == 0x1C) {
            recv_data_cnt = read_data0.byte1 + read_data0.byte2 * 16;
            DISPDBG(&quot;packet_type=0x%x,recv_data_cnt = %d\n&quot;, packet_type, recv_data_cnt);
            if(recv_data_cnt &gt; RT_MAX_NUM)
            {
                DISPMSG(&quot;DSI read long packet data exceeds 10 bytes \n&quot;);
                recv_data_cnt = RT_MAX_NUM;
            } 

            if (recv_data_cnt &gt; dsi_params-&gt;lcm_esd_check_table[i].count) {
                recv_data_cnt = dsi_params-&gt;lcm_esd_check_table[i].count;
            }

            if (recv_data_cnt &lt;= 4) {
                memcpy((void *)buffer, (void *)&amp;read_data1, recv_data_cnt);
            } else if (recv_data_cnt &lt;= 8) {
                memcpy((void *)buffer, (void *)&amp;read_data1, 4);
                memcpy((void *)(buffer + 4), (void *)&amp;read_data2, recv_data_cnt - 4);
            } else {
                memcpy((void *)buffer, (void *)&amp;read_data1, 4);
                memcpy((void *)(buffer + 4), (void *)&amp;read_data2, 4);
                memcpy((void *)(buffer + 8), (void *)&amp;read_data3, recv_data_cnt - 8);
            }

            for (j = 0; j &lt; recv_data_cnt; j++) {
                DISPDBG(&quot;buffer[%d]=0x%x\n&quot;, j, buffer[j]);
                if (buffer[j] != dsi_params-&gt;lcm_esd_check_table[i].para_list[j]) {
                    result= 1;
                    DISPMSG(&quot;[ESD]CMP i %d return value 0x%x,para_list[%d]=0x%x\n&quot;, i,
                    buffer[j], j, dsi_params-&gt;lcm_esd_check_table[i].para_list[j]);
                    break;
                }
            }
        } else if (packet_type == 0x11 ||
        packet_type == 0x12 ||
        packet_type == 0x21 ||
        packet_type == 0x22) {
            /* short read response */
            if (packet_type == 0x11 || packet_type == 0x21)
                recv_data_cnt = 1;
            else
                recv_data_cnt = 2;

            if (recv_data_cnt &gt; dsi_params-&gt;lcm_esd_check_table[i].count) {
                recv_data_cnt = dsi_params-&gt;lcm_esd_check_table[i].count;
            }

            memcpy((void *)buffer, (void *)&amp;read_data0.byte1, recv_data_cnt);
            DISPDBG(&quot;packet_type=0x%x,recv_data_cnt = %d\n&quot;, packet_type, recv_data_cnt);

            for (j = 0; j &lt; recv_data_cnt; j++) {
                DISPDBG(&quot;buffer[%d]=0x%x\n&quot;, j, buffer[j]);
                if (buffer[j] != dsi_params-&gt;lcm_esd_check_table[i].para_list[j]) {
                    result= 1;
                    DISPMSG(&quot;[ESD]CMP i %d return value 0x%x,para_list[%d]=0x%x\n&quot;, i,
                    buffer[j], j, dsi_params-&gt;lcm_esd_check_table[i].para_list[j]);
                    break;
                }
            }
        } else if (packet_type == 0x02) {
            DISPMSG(&quot;read return type is 0x02\n&quot;);
            result = 1;
        } else {
            DISPMSG(&quot;read return type is non-recognite, type = 0x%x\n&quot;, packet_type);
            result = 1;
        }

        if (result == 0) {
            /* clear rx data */
            /* DSI_OUTREG32(NULL, &amp;DSI_REG[dsi_i]-&gt;DSI_RX_DATA0,0); */
            ret = 0; /* esd pass */
        } else {
            ret = 1; /* esd fail */
            break;
        }
    }

} else if (state == CMDQ_ESD_ALLC_SLOT) {
    /* create 3*4 slot */
    for(h = 0; h &lt; 4; h++){
        cmdqBackupAllocateSlot(&amp;hSlot[h], 3);
    }
} else if (state == CMDQ_ESD_FREE_SLOT) {
    if (hSlot[0] &amp;&amp; hSlot[1] &amp;&amp; hSlot[2] &amp;&amp; hSlot[3]) {
        for(h = 0; h &lt; 4; h++){
            cmdqBackupFreeSlot(hSlot[h]);
            hSlot[h] = 0;
        }
    }
} else if (state == CMDQ_STOP_VDO_MODE) {
    /* use cmdq to stop dsi vdo mode */
    /* -1. stop TE_RDY IRQ */
    DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_INT_ENABLE_REG,
              DSI_REG[i]-&gt;DSI_INTEN, TE_RDY, 0);

    /* 0. set dsi cmd mode */
    DSI_SetMode(module, cmdq_trigger_handle, CMD_MODE);

    /* 1. polling dsi not busy */
    i = DSI_MODULE_BEGIN(module);
    if (i == 0) {
        /* DSI0/DUAL */
        /* polling vm done */
        /* polling dsi busy */
        DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[i]-&gt;DSI_INTSTA,
                  0x80000000, 0);
</code></pre><p>#if 0<br>            i = DSI_MODULE_END(module);<br>            if (i == 1) {    /<em> DUAL </em>/<br>                DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[i]-&gt;DSI_INTSTA,<br>                          0x80000000, 0);<br>            }</p>
<p>#endif<br>        }</p>
<p>#if 0<br>        else {    /<em> DSI1 </em>/<br>            DSI_POLLREG32(cmdq_trigger_handle, &amp;DSI_REG[i]-&gt;DSI_INTSTA,<br>                      0x80000000, 0);<br>        }</p>
<p>#endif<br>        /<em> 2.dual dsi need do reset DSI_DUAL_EN/DSI_START </em>/<br>        if (module == DISP_MODULE_DSIDUAL) {<br>            DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_COM_CTRL_REG,<br>                      DSI_REG[0]-&gt;DSI_COM_CTRL, DSI_DUAL_EN, 0);<br>            DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_COM_CTRL_REG,<br>                      DSI_REG[1]-&gt;DSI_COM_CTRL, DSI_DUAL_EN, 0);<br>            DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_START_REG,<br>                      DSI_REG[0]-&gt;DSI_START, DSI_START, 0);<br>            DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_START_REG,<br>                      DSI_REG[1]-&gt;DSI_START, DSI_START, 0);<br>        }<br>        /<em> 3.disable HS </em>/<br>        /<em> DSI_clk_HS_mode(module, cmdq_trigger_handle, false); </em>/</p>
<pre><code>} else if (state == CMDQ_START_VDO_MODE) {

    /* 0. dual dsi set DSI_START/DSI_DUAL_EN */
    if (module == DISP_MODULE_DSIDUAL) {
        /* must set DSI_START to 0 before set dsi_dual_en, don&apos;t know why.2014.02.15 */
        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_START_REG,
                  DSI_REG[0]-&gt;DSI_START, DSI_START, 0);
        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_START_REG,
                  DSI_REG[1]-&gt;DSI_START, DSI_START, 0);

        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_COM_CTRL_REG,
                  DSI_REG[0]-&gt;DSI_COM_CTRL, DSI_DUAL_EN, 1);
        DSI_OUTREGBIT(cmdq_trigger_handle, struct DSI_COM_CTRL_REG,
                  DSI_REG[1]-&gt;DSI_COM_CTRL, DSI_DUAL_EN, 1);

    }
    /* 1. set dsi vdo mode */
    DSI_SetMode(module, cmdq_trigger_handle, dsi_params-&gt;mode);

    /* 2. enable HS */
    /* DSI_clk_HS_mode(module, cmdq_trigger_handle, true); */

    /* 3. enable mutex */
    /* ddp_mutex_enable(mutex_id_for_latest_trigger,0,cmdq_trigger_handle); */

    /* 4. start dsi */
    /* DSI_Start(module, cmdq_trigger_handle); */

} else if (state == CMDQ_DSI_RESET) {
    DISPMSG(&quot;CMDQ Timeout, Reset DSI\n&quot;);
    DSI_DumpRegisters(module, 1);
    DSI_Reset(module, NULL);
}

return ret;
</code></pre><p>}</p>
<p>四．案例分析<br>1.哪个案子的哪种显示屏：V166-357D jd9365<br>2.现象：有进行复位动作，但是屏无法恢复<br>3.分析：读0x0a寄存器，出现异常的情况为0x18或者0x08，且经过连续5次recovery之后异常没有消除，最终退出了recovery kthread屏也没有恢复<br>4.解决办法：<br>a.修改lcm_init和lcm_suspend时lcm rst脚的控制方法及延时的时间，保证每一次初始化过程更合理有效</p>
<p>b.增加初始化时下发0x11的次数确保下发成功</p>
<p>c. 在primary_display_esd_check_worker_kthread中增加复位延时的时间，确保有足够的时间能使0x0a恢复正常之后再进行下一次esd check</p>
<p>解决办法主要是c，另外中间的延时可以具体细调，不能延时过高影响用户体验，也不能延时太低再出现esd recovery fail。</p>
<p>6.Himax TP的ESD读寄存器只支持mipi长包，需要识别各个寄存器返回多个值，参考FAQ13728在ddp_dsi.c的ESD_CMP处添加修改。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2019/04/09/lcm-ESD/" data-title="lcm ESD | Born" data-tsina class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2019/04/11/Android4-2移植rtl8192cu驱动要点/" title="Android4.2移植rtl8192cu驱动要点">
  <strong>上一篇：</strong><br>
  <span>
  Android4.2移植rtl8192cu驱动要点</span>
</a>
</div>


<div class="next">
<a href="/2019/04/09/Linux-usb子系统（一）：子系统架构/" title="Linux usb子系统（一）：子系统架构">
 <strong>下一篇：</strong><br> 
 <span>Linux usb子系统（一）：子系统架构
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MTK-平台LCM-ESD客制化及代码分析和案例"><span class="toc-number">1.</span> <span class="toc-text">MTK 平台LCM ESD客制化及代码分析和案例</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Born&#39;s Blog">Born&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self" frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Json Born in Google. <br>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Born">Born</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
